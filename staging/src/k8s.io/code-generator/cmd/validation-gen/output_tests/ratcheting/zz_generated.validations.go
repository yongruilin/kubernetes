//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by validation-gen. DO NOT EDIT.

package ratcheting

import (
	context "context"

	equality "k8s.io/apimachinery/pkg/api/equality"
	operation "k8s.io/apimachinery/pkg/api/operation"
	safe "k8s.io/apimachinery/pkg/api/safe"
	validate "k8s.io/apimachinery/pkg/api/validate"
	field "k8s.io/apimachinery/pkg/util/validation/field"
	testscheme "k8s.io/code-generator/cmd/validation-gen/testscheme"
)

func init() { localSchemeBuilder.Register(RegisterValidations) }

// RegisterValidations adds validation functions to the given scheme.
// Public to allow building arbitrary schemes.
func RegisterValidations(scheme *testscheme.Scheme) error {
	scheme.AddValidationFunc((*RootStruct)(nil), func(ctx context.Context, op operation.Operation, obj, oldObj interface{}) field.ErrorList {
		return Validate_RootStruct(ctx, op, nil /* fldPath */, obj.(*RootStruct), safe.Cast[*RootStruct](oldObj))
	})
	return nil
}

func Validate_RootStruct(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *RootStruct) (errs field.ErrorList) {
	// field RootStruct.TypeMeta has no validation

	// field RootStruct.MyStruct
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *Struct) (errs field.ErrorList) {
			errs = append(errs, Validate_Struct(ctx, op, fldPath, obj, oldObj)...)
			return
		}(fldPath.Child("myStruct"), &obj.MyStruct, safe.Field(oldObj, func(oldObj *RootStruct) *Struct { return &oldObj.MyStruct }))...)

	return errs
}

func Validate_Struct(ctx context.Context, op operation.Operation, fldPath *field.Path, obj, oldObj *Struct) (errs field.ErrorList) {
	// type Struct
	errs = append(errs, validate.ImmutableNonComparable(ctx, op, fldPath, obj, oldObj)...)
	// ratcheting is enabled for this field
	if op.Type == operation.Update && len(errs) > 0 && equality.Semantic.DeepEqual(obj, oldObj) {
		return nil // no changes
	}

	// field Struct.ListField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []OtherStruct) (errs field.ErrorList) {
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, func(a OtherStruct, b OtherStruct) bool { return a.Key1Field == b.Key1Field }, validate.Immutable)...)
			// ratcheting is enabled for this field
			if op.Type == operation.Update && len(errs) > 0 && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil // no changes
			}
			return
		}(fldPath.Child("listField"), obj.ListField, safe.Field(oldObj, func(oldObj *Struct) []OtherStruct { return oldObj.ListField }))...)

	// field Struct.ListTypedefField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj []OtherTypedefStruct) (errs field.ErrorList) {
			errs = append(errs, validate.EachSliceVal(ctx, op, fldPath, obj, oldObj, func(a OtherTypedefStruct, b OtherTypedefStruct) bool { return a.Key1Field == b.Key1Field }, validate.Immutable)...)
			// ratcheting is disabled for this field
			return
		}(fldPath.Child("listTypedefField"), obj.ListTypedefField, safe.Field(oldObj, func(oldObj *Struct) []OtherTypedefStruct { return oldObj.ListTypedefField }))...)

	// field Struct.MinField
	errs = append(errs,
		func(fldPath *field.Path, obj, oldObj *int) (errs field.ErrorList) {
			errs = append(errs, validate.Minimum(ctx, op, fldPath, obj, oldObj, 1)...)
			// ratcheting is enabled for this field
			if op.Type == operation.Update && len(errs) > 0 && equality.Semantic.DeepEqual(obj, oldObj) {
				return nil // no changes
			}
			return
		}(fldPath.Child("minField"), &obj.MinField, safe.Field(oldObj, func(oldObj *Struct) *int { return &oldObj.MinField }))...)

	return errs
}
