/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bytes"
	"cmp"
	"fmt"
	"io"
	"reflect"
	"slices"
	"strconv"
	"strings"
	"unicode"

	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/apimachinery/pkg/util/validation/field"
	"k8s.io/code-generator/cmd/validation-gen/validators"
	"k8s.io/gengo/v2"
	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/parser/tags"
	"k8s.io/gengo/v2/types"
	"k8s.io/klog/v2"
)

func mkPkgNames(pkg string, names ...string) []types.Name {
	result := make([]types.Name, 0, len(names))
	for _, name := range names {
		result = append(result, types.Name{Package: pkg, Name: name})
	}
	return result
}

var (
	fieldPkg            = "k8s.io/apimachinery/pkg/util/validation/field"
	fieldPkgSymbols     = mkPkgNames(fieldPkg, "ErrorList", "InternalError", "Path")
	fmtPkgSymbols       = mkPkgNames("fmt", "Errorf")
	safePkg             = "k8s.io/apimachinery/pkg/api/safe"
	safePkgSymbols      = mkPkgNames(safePkg, "NewListMap", "Field", "Lookup", "Cast", "PtrTo", "Deref", "Ident")
	operationPkg        = "k8s.io/apimachinery/pkg/api/operation"
	operationPkgSymbols = mkPkgNames(operationPkg, "Context", "Update")
)

// genValidations produces a file with autogenerated validations.
type genValidations struct {
	generator.GoGenerator
	outputPackage       string
	inputToPkg          map[string]string // Maps input packages to generated validation packages
	rootTypes           []*types.Type
	discovered          *typeDiscoverer
	imports             namer.ImportTracker
	validator           validators.DeclarativeValidator
	hasValidationsCache map[*typeNode]bool
	schemeRegistry      types.Name
}

// NewGenValidations cretes a new generator for the specified package.
func NewGenValidations(outputFilename, outputPackage string, rootTypes []*types.Type, discovered *typeDiscoverer, inputToPkg map[string]string, schemeRegistry types.Name) generator.Generator {
	return &genValidations{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename,
		},
		outputPackage:       outputPackage,
		inputToPkg:          inputToPkg,
		rootTypes:           rootTypes,
		discovered:          discovered,
		imports:             generator.NewImportTrackerForPackage(outputPackage),
		hasValidationsCache: map[*typeNode]bool{},
		schemeRegistry:      schemeRegistry,
	}
}

func (g *genValidations) Namers(_ *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.outputPackage, g.imports),
	}
}

func (g *genValidations) Filter(_ *generator.Context, t *types.Type) bool {
	// We want to emit code for all root types.
	for _, rt := range g.rootTypes {
		if rt == t {
			return true
		}
	}
	// We want to emit for any other type that is transitively part of a root
	// type and has validations.
	n := g.discovered.typeNodes[t]
	return n != nil && g.hasValidations(n)
}

func (g *genValidations) Imports(_ *generator.Context) (imports []string) {
	var importLines []string
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func (g *genValidations) isOtherPackage(pkg string) bool {
	if pkg == g.outputPackage {
		return false
	}
	if strings.HasSuffix(pkg, `"`+g.outputPackage+`"`) {
		return false
	}
	return true
}

func (g *genValidations) Init(c *generator.Context, w io.Writer) error {
	klog.V(5).Infof("emitting registration code")
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	g.emitRegisterFunction(c, g.schemeRegistry, sw)
	if err := sw.Error(); err != nil {
		return err
	}
	return nil
}

func (g *genValidations) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	klog.V(5).Infof("emitting validation code for type %v", t)

	sw := generator.NewSnippetWriter(w, c, "$", "$")
	g.emitValidationVariables(c, t, sw)
	g.emitValidationFunction(c, t, sw)
	if err := sw.Error(); err != nil {
		return err
	}
	return nil
}

// hasValidations checks and caches whether the given typeNode has any
// validations, transitively.
func (g *genValidations) hasValidations(n *typeNode) bool {
	seen := map[*typeNode]bool{}
	return g.hasValidationsImpl(n, seen)
}

// hasValidationsImpl implements hasValidations without risk of infinite
// recursion.
func (g *genValidations) hasValidationsImpl(n *typeNode, seen map[*typeNode]bool) bool {
	if n == nil {
		return false
	}

	if seen[n] {
		return false // prevent infinite recursion
	}
	seen[n] = true

	if r, found := g.hasValidationsCache[n]; found {
		return r
	}

	r := g.hasValidationsMiss(n, seen)
	g.hasValidationsCache[n] = r
	return r
}

// hasValidationsMiss is called in case of a cache miss.
func (g *genValidations) hasValidationsMiss(n *typeNode, seen map[*typeNode]bool) bool {
	if !n.typeValidations.Empty() {
		return true
	}
	allChildren := n.fields
	if n.key != nil {
		allChildren = append(allChildren, n.key)
	}
	if n.elem != nil {
		allChildren = append(allChildren, n.elem)
	}
	for _, c := range allChildren {
		if !c.fieldValidations.Empty() || !c.keyValidations.Empty() || !c.elemValidations.Empty() {
			return true
		}
		if g.hasValidationsImpl(c.node, seen) {
			return true
		}
		for _, subfield := range c.subfieldValidations {
			// c.subfield is created during parsing when a +k8s:subfield tag is found so we
			// can assume there is a validation and don't need to recurse on the node
			if !subfield.fieldValidations.Empty() {
				return true
			}
		}
	}
	return false
}

// typeDiscoverer contains fields necessary to build graphs of types.
type typeDiscoverer struct {
	validatorRegistry *validators.ValidatorRegistry
	validator         validators.DeclarativeValidator // legacy
	inputToPkg        map[string]string

	// typeNodes holds a map of gengo Type to typeNode for all of the types
	// encountered during discovery.
	typeNodes map[*types.Type]*typeNode
}

// NewTypeDiscoverer creates and initializes a NewTypeDiscoverer.
func NewTypeDiscoverer(validatorRegistry *validators.ValidatorRegistry, validator validators.DeclarativeValidator, inputToPkg map[string]string) *typeDiscoverer {
	return &typeDiscoverer{
		validatorRegistry: validatorRegistry,
		validator:         validator,
		inputToPkg:        inputToPkg,
		typeNodes:         map[*types.Type]*typeNode{},
	}
}

// childNode represents a type which is used in another type (e.g. a struct
// field).
type childNode struct {
	name      string      // the field name in the parent, populated when this node is a struct field
	jsonName  string      // always populated when name is populated
	childType *types.Type // the real type of the child (may be a pointer)
	node      *typeNode   // the node of the child's value type, or nil if it is in a foreign package

	fieldValidations validators.Validations // validations on the field
	keyValidations   validators.Validations // validations on each key of a map field
	elemValidations  validators.Validations // validations on each value of a list or map

	// struct fields can have per-child-member validations.
	subfieldValidations []*childNode
}

// typeNode represents a node in the type-graph, annotated with information
// about validations.  Everything in this type, transitively, is assoctiated
// with the type, and not any specific instance of that type (e.g. when used as
// a field in a struct.
type typeNode struct {
	valueType *types.Type // never a pointer, but may be a map, slice, struct, etc.
	funcName  types.Name  // populated when this type is has a validation function

	fields      []*childNode   // populated when this type is a struct
	key         *childNode     // populated when this type is a map
	elem        *childNode     // populated when this type is a map or slice
	underlying  *childNode     // populated when this type is an alias
	listMapKeys []types.Member // populated with listMapKey values when this type is listType=map slice

	typeValidations validators.Validations // validations on the type
	keyValidations  validators.Validations // validations on each key of a map type
	elemValidations validators.Validations // validations on each value of a list or map
}

// lookupField returns the childNode with the specified JSON name.
func (n typeNode) lookupField(jsonName string) *childNode {
	for _, fld := range n.fields {
		if fld.jsonName == jsonName {
			return fld
		}
	}
	return nil
}

const (
	// This tag defines a validation which is to be run on each key in a map.
	eachKeyTag = "k8s:eachKey"
	// This tag defines a validation which is to be run on each value in a map
	// or slice.
	eachValTag = "k8s:eachVal"
	// This tag defines a validation which is to be run on a "subfield" of
	// the struct tagged.
	subfieldTag = "k8s:subfield"
	// This tag designates a child field as part of the list-map key for a list
	// of structs.
	listMapKeyTag = "k8s:listMapKey"
)

// builtinTagDocs returns information about the hard-coded tags.
func builtinTagDocs() []validators.TagDoc {
	return []validators.TagDoc{{
		Tag:         eachKeyTag,
		Description: "Declares a validation for map keys.",
		Contexts:    []validators.TagScope{validators.TagScopeType, validators.TagScopeField},
		Payloads: []validators.TagPayloadDoc{{
			Description: "<validation-tag>",
			Docs:        "This tag will be evaluated for each key of a map.",
		}},
	}, {
		Tag:         eachValTag,
		Description: "Declares a validation for map and slice values.",
		Contexts:    []validators.TagScope{validators.TagScopeType, validators.TagScopeField},
		Payloads: []validators.TagPayloadDoc{{
			Description: "<validation-tag>",
			Docs:        "This tag will be evaluated for each value of a map or slice.",
		}},
	}, {
		Tag:         listMapKeyTag,
		Description: "Declares a named field of a list's value type as part of the list-map key.",
		Contexts:    []validators.TagScope{validators.TagScopeType, validators.TagScopeField},
		Payloads: []validators.TagPayloadDoc{{
			Description: "<field-name>",
			Docs:        "This values names a field of a list's value type.",
		}},
	}, {
		Tag:         fmt.Sprintf("%s(<field-name>)", subfieldTag),
		Description: "Declares a validation for a specified subfield of the struct. The subfield must be a direct field of the struct, or of an embedded struct",
		Contexts:    []validators.TagScope{validators.TagScopeField},
		Payloads: []validators.TagPayloadDoc{{
			Description: "<validation-tag>",
			Docs:        "This tag will be evaluated for the subfield of the struct.",
		}},
	}}
}

// DiscoverType walks the given type recursively, building a type-graph in this
// typeDiscoverer.  If this is called multiple times for different types, the
// multiple graphs will be stored, and where types overlap, they will be
// merged.
func (td *typeDiscoverer) DiscoverType(t *types.Type) error {
	if t.Kind == types.Pointer {
		return fmt.Errorf("type %v: pointer root-types are not supported", t)
	}
	fldPath := field.NewPath(t.Name.String())
	if node, err := td.discover(t, fldPath); err != nil {
		return err
	} else if node == nil {
		panic(fmt.Sprintf("discovered a nil node for type %v", t))
	}
	return nil
}

// discover walks the given type recursively and returns a typeNode
// representing it.
func (td *typeDiscoverer) discover(t *types.Type, fldPath *field.Path) (*typeNode, error) {
	// With the exception of builtins (which gengo puts in package ""), we
	// can't traverse into packages which are not being processed by this tool.
	if t.Name.Package != "" {
		_, ok := td.inputToPkg[t.Name.Package]
		if !ok {
			return nil, nil
		}
	}
	if t.Kind == types.Pointer {
		// Catch some edge cases that we don't want to handle.
		switch t.Elem.Kind {
		case types.Pointer:
			return nil, fmt.Errorf("field %s (%s): pointers to pointers are not supported", fldPath.String(), t)
		case types.Slice:
			return nil, fmt.Errorf("field %s (%s): pointers to slices are not supported", fldPath.String(), t)
		case types.Map:
			return nil, fmt.Errorf("field %s (%s): pointers to maps are not supported", fldPath.String(), t)
		}
		// Remove pointerness.
		t = t.Elem
	}
	// If we have done this type already, we can stop here and break any
	// recursion.
	if node, found := td.typeNodes[t]; found {
		return node, nil
	}

	// If we are descending into a named type, reboot the field path for better
	// logging.  Otherwise the field path might come in as something like
	// <type1>.<field1>.<field2> which is true, but not super useful.
	switch t.Kind {
	case types.Alias, types.Struct:
		fldPath = field.NewPath(t.Name.String())
	}

	thisNode := &typeNode{
		valueType: t,
	}
	td.typeNodes[t] = thisNode

	// If this is a known, named type, we can call its validation function.
	switch t.Kind {
	case types.Alias, types.Struct:
		if fn, ok := td.getValidationFunctionName(t); ok {
			thisNode.funcName = fn
		}
	}

	// Discover into this type before extracting type validations.
	switch t.Kind {
	case types.Builtin:
		// Nothing more to do.
	case types.Alias:
		// Discover into this alias, recursively.
		if err := td.discoverAlias(thisNode, fldPath); err != nil {
			return nil, err
		}
	case types.Struct:
		// Discover into this struct, recursively.
		if err := td.discoverStruct(thisNode, fldPath); err != nil {
			return nil, err
		}
	case types.Slice, types.Array:
		// Discover the element type.
		if node, err := td.discover(t.Elem, fldPath.Key("vals")); err != nil {
			return nil, err
		} else {
			thisNode.elem = &childNode{
				childType: t.Elem,
				node:      node,
			}
		}
	case types.Map:
		// Discover the key type.
		if node, err := td.discover(t.Key, fldPath.Key("keys")); err != nil {
			return nil, err
		} else {
			thisNode.key = &childNode{
				childType: t.Key,
				node:      node,
			}
		}

		// Discover the element type.
		if node, err := td.discover(t.Elem, fldPath.Key("vals")); err != nil {
			return nil, err
		} else {
			thisNode.elem = &childNode{
				childType: t.Elem,
				node:      node,
			}
		}
	default:
		return nil, fmt.Errorf("field %s (%v, kind %v) is not supported", fldPath.String(), t, t.Kind)
	}

	// Extract any type-attached validation rules.  We do this AFTER descending
	// into the type, so that these validators have access to the full type.
	// For example, all struct field validators get called before the type
	// validators.  This does not influence the order in which the validations
	// are called in emitted code, just how we evaluate what to emit.
	context := validators.Context{
		Scope: validators.TagScopeType,
		Type:  t,
	}
	if t.Kind == types.Alias {
		context.Parent = t
		context.Type = t.Underlying
	}
	if validations, err := td.validatorRegistry.ExtractValidations(context, t.CommentLines); err != nil {
		return nil, fmt.Errorf("%v: %w", fldPath, err)
	} else {
		if !validations.Empty() {
			klog.V(5).InfoS("found type-attached validations", "n", validations.Len())
			thisNode.typeValidations.Add(validations)
		}
	}
	// legacy
	if validations, err := td.validator.ExtractValidations(t, t.CommentLines); err != nil {
		return nil, fmt.Errorf("%v: %w", fldPath, err)
	} else {
		if !validations.Empty() {
			klog.V(5).InfoS("found type-attached validations", "n", validations.Len())
			thisNode.typeValidations.Add(validations)
		}
	}

	return thisNode, nil
}

// discoverStruct walks a struct type recursively.
func (td *typeDiscoverer) discoverStruct(thisNode *typeNode, fldPath *field.Path) error {
	var fields []*childNode

	// Discover into each field of this struct.
	doOneField := func(memb types.Member, name, jsonName string) error {
		klog.V(5).InfoS("field", "name", name, "jsonName", jsonName, "type", memb.Type)

		// Discover the field type.
		childPath := fldPath.Child(name)
		childType := memb.Type
		var child *childNode
		if node, err := td.discover(childType, childPath); err != nil {
			return err
		} else {
			child = &childNode{
				name:      name,
				jsonName:  jsonName,
				childType: childType,
				node:      node,
			}
			// Extract +k8s:listMapKeys for correlating object and oldObject during
			// update validation.
			if listMapKeyNames, ok := gengo.ExtractCommentTags("+", memb.CommentLines)[listMapKeyTag]; ok {
				// List-maps can only be list types.
				switch childType.Kind {
				case types.Slice, types.Array:
					// OK
				default:
					return fmt.Errorf("%v: +%s was specified on a field of non-list type %s", childPath, listMapKeyTag, memb.Type)
				}

				// Discard any pointerness.
				elem := childType.Elem
				for elem.Kind == types.Pointer {
					elem = elem.Elem
				}
				// If we find a nil node, it's not a type we can handle.
				if td.typeNodes[elem] == nil {
					return fmt.Errorf("%v: +%s was specified on a field of non-included type %s", childPath, listMapKeyTag, elem)
				}

				// Discard any alias indirection.
				underlying := elem
				for elem.Kind == types.Alias {
					underlying = elem.Underlying
				}
				// List-maps can only be lists of structs.
				if underlying.Kind != types.Struct {
					return fmt.Errorf("%v: +%s was specified on a list of non-struct type %s", childPath, listMapKeyTag, elem)
				}

				if keys, err := extractListMapKeys(underlying, listMapKeyNames); err != nil {
					return fmt.Errorf("%v: %w", childPath, err)
				} else {
					node.listMapKeys = keys
				}
			}
		}

		// Extract any field-attached validation rules.
		context := validators.Context{
			Scope:  validators.TagScopeField,
			Type:   memb.Type,
			Parent: thisNode.valueType,
			Member: &memb,
		}
		if validations, err := td.validatorRegistry.ExtractValidations(context, memb.CommentLines); err != nil {
			return fmt.Errorf("field %s: %w", childPath.String(), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found field-attached validations", "n", validations.Len())
				child.fieldValidations.Add(validations)
				if len(validations.Variables) > 0 {
					return fmt.Errorf("%v: variable generation is not supported for field validations", childPath)
				}
			}
		}
		// legacy
		if validations, err := td.validator.ExtractValidations(memb.Type, memb.CommentLines); err != nil {
			return fmt.Errorf("field %s: %w", childPath.String(), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found field-attached validations", "n", validations.Len())
				child.fieldValidations.Add(validations)
				if len(validations.Variables) > 0 {
					return fmt.Errorf("%v: variable generation is not supported for field validations", childPath)
				}
			}
		}

		// Add any other field-attached "special" validators.
		switch childType.Kind {
		case types.Slice, types.Array:
			// Extract any embedded list-validation rules.
			valCtxt := validators.Context{
				Scope:  validators.TagScopeListVal,
				Type:   childType.Elem,
				Parent: memb.Type,
			}
			if validations, err := td.extractEmbeddedValidations(eachValTag, valCtxt, memb.CommentLines, childType.Elem); err != nil {
				return fmt.Errorf("%v: %w", childPath.Key("vals"), err)
			} else {
				if !validations.Empty() {
					klog.V(5).InfoS("found list-validations", "n", validations.Len())
					child.elemValidations.Add(validations)
					if len(validations.Variables) > 0 {
						return fmt.Errorf("%v: variable generation is not supported for list value validations", childPath)
					}
				}
			}
		case types.Struct, types.Pointer:
			if childType.Kind == types.Pointer {
				if childType.Elem.Kind == types.Struct {
					// set childType to underlying struct from struct pointer
					childType = childType.Elem
				} else {
					break
				}
			}
			// To support subfield validations, here we build up childNode types that have a +k8s:subfield tag reference
			// so that we can later generate calls to field specific validators from the child.subfield information.
			doOneChildField := func(subfield types.Member, name, jsonName string) error {
				klog.V(5).InfoS("field", "name", name, "jsonName", jsonName, "type", memb.Type)

				context := validators.Context{
					Scope:  validators.TagScopeField,
					Type:   subfield.Type,
					Parent: childType, // the struct being iterated
					Member: &subfield,
				}
				// Passing memb.CommentLines because subfield validations are
				// declared on the *parent* type (memb) field and not the *subfield* type (subfield).
				if validations, err := td.extractSubfieldValidations(context, jsonName, memb.CommentLines); err != nil {
					return fmt.Errorf("%v: %w", childPath.Child(name), err)
				} else {
					if validations.Empty() {
						return nil
					}
					klog.V(5).InfoS("found field-attached subfield-validations", "n", validations.Len())

					subchild := &childNode{
						name:             name,
						jsonName:         jsonName,
						childType:        subfield.Type,
						fieldValidations: validations,
					}
					child.subfieldValidations = append(child.subfieldValidations, subchild)
				}
				return nil
			}
			if err := forEachField(childType, doOneChildField); err != nil {
				return err
			}
		case types.Map:
			// Extract any embedded key-validation rules.
			keyCtxt := validators.Context{
				Scope:  validators.TagScopeMapKey,
				Type:   childType.Key,
				Parent: memb.Type,
			}
			if validations, err := td.extractEmbeddedValidations(eachKeyTag, keyCtxt, memb.CommentLines, childType.Key); err != nil {
				return fmt.Errorf("%v: %w", childPath.Key("keys"), err)
			} else {
				if !validations.Empty() {
					klog.V(5).InfoS("found key-validations", "n", validations.Len())
					child.keyValidations.Add(validations)
					if len(validations.Variables) > 0 {
						return fmt.Errorf("%v: variable generation is not supported for map key validations", childPath)
					}
				}
			}
			// Extract any embedded val-validation rules.
			valCtxt := validators.Context{
				Scope:  validators.TagScopeMapVal,
				Type:   childType.Elem,
				Parent: memb.Type,
			}
			if validations, err := td.extractEmbeddedValidations(eachValTag, valCtxt, memb.CommentLines, childType.Elem); err != nil {
				return fmt.Errorf("%v: %w", childPath.Key("vals"), err)
			} else {
				if !validations.Empty() {
					klog.V(5).InfoS("found list-validations", "n", validations.Len())
					child.elemValidations.Add(validations)
					if len(validations.Variables) > 0 {
						return fmt.Errorf("%v: variable generation not supported for map value validations", childPath)
					}
				}
			}
		}

		fields = append(fields, child)
		return nil
	}

	if err := forEachField(thisNode.valueType, doOneField); err != nil {
		return err
	}

	thisNode.fields = fields
	return nil
}

// discoverAlias walks an alias type recursively.
func (td *typeDiscoverer) discoverAlias(thisNode *typeNode, fldPath *field.Path) error {
	t := thisNode.valueType
	underlying := t.Underlying

	// Note: By the language definition, what gengo calls "Aliases" (really
	// just "type definitions") have underlying types of the type literal.
	// In other words, if we define `type T1 string` and `type T2 T1`, the
	// underlying type of T2 is string, not T1.  This means that:
	//    1) We will emit code for both underlying types. If the underlying
	//       type is a struct with many fields, we will emit two identical
	//       functions.
	//    2) Validating a field of type T2 will NOT call any validation
	//       defined on the type T1.
	//    3) In the case of a type definition whose RHS is a struct which
	//       has fields with validation tags, the validation for those fields
	//       WILL be called from the generated for for the new type.

	// Discover the underlying type.
	var child *childNode
	if node, err := td.discover(underlying, fldPath); err != nil {
		return err
	} else {
		child = &childNode{
			childType: underlying,
			node:      node,
		}
	}
	thisNode.underlying = child

	// Add any other type-attached "special" validators.
	switch underlying.Kind {
	case types.Slice, types.Array:
		// Extract any embedded list-validation rules.
		valCtxt := validators.Context{
			Scope:  validators.TagScopeListVal,
			Type:   underlying.Elem,
			Parent: underlying,
		}
		if validations, err := td.extractEmbeddedValidations(eachValTag, valCtxt, thisNode.valueType.CommentLines, underlying); err != nil {
			return fmt.Errorf("%v: %w", fldPath.Key("vals"), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found list-validations", "n", validations.Len())
				child.elemValidations.Add(validations)
			}
		}
	case types.Map:
		// Extract any embedded key-validation rules.
		keyCtxt := validators.Context{
			Scope:  validators.TagScopeMapKey,
			Type:   underlying.Key,
			Parent: underlying,
		}
		if validations, err := td.extractEmbeddedValidations(eachKeyTag, keyCtxt, thisNode.valueType.CommentLines, underlying); err != nil {
			return fmt.Errorf("%v: %w", fldPath.Key("keys"), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found key-validations", "n", validations.Len())
				child.keyValidations.Add(validations)
			}
		}
		// Extract any embedded val-validation rules.
		valCtxt := validators.Context{
			Scope:  validators.TagScopeMapVal,
			Type:   underlying.Elem,
			Parent: underlying,
		}
		if validations, err := td.extractEmbeddedValidations(eachValTag, valCtxt, thisNode.valueType.CommentLines, underlying); err != nil {
			return fmt.Errorf("%v: %w", fldPath.Key("vals"), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found val-validations", "n", validations.Len())
				child.elemValidations.Add(validations)
			}
		}
	}

	return nil
}

// FIXME: drop the `t` arg when converted.
func (td *typeDiscoverer) extractEmbeddedValidations(tag string, context validators.Context, comments []string, t *types.Type) (validators.Validations, error) {
	var result validators.Validations
	if tagVals, found := gengo.ExtractCommentTags("+", comments)[tag]; found {
		for _, tagVal := range tagVals {
			fakeComments := []string{tagVal}
			if validations, err := td.validatorRegistry.ExtractValidations(context, fakeComments); err != nil {
				return result, err
			} else {
				result.Add(validations)
			}
			// legacy
			if validations, err := td.validator.ExtractValidations(t, fakeComments); err != nil {
				return result, err
			} else {
				result.Add(validations)
			}
		}
	}
	return result, nil
}

// getValidationFunctionName looks up the name of the specified type's
// validation function.
//
// TODO: Currently this is a "blind" call - we hope that the expected function
// exists, but we don't verify that, and we only emit calls into packages which
// are being processed by this generator. For cross-package calls we will need
// to verify the target, either by naming convention + fingerprint or by
// explicit comment-tags or something.
func (td *typeDiscoverer) getValidationFunctionName(t *types.Type) (types.Name, bool) {
	pkg, ok := td.inputToPkg[t.Name.Package]
	if !ok {
		return types.Name{}, false
	}
	return types.Name{Package: pkg, Name: "Validate_" + t.Name.Name}, true
}

func mkSymbolArgs(c *generator.Context, names []types.Name) generator.Args {
	args := generator.Args{}
	for _, name := range names {
		args[name.Name] = c.Universe.Type(name)
	}
	return args
}

// emitRegisterFunction emits the type-registration logic for validation
// functions.
func (g *genValidations) emitRegisterFunction(c *generator.Context, schemeRegistry types.Name, sw *generator.SnippetWriter) {
	scheme := c.Universe.Type(schemeRegistry)
	schemePtr := &types.Type{
		Kind: types.Pointer,
		Elem: scheme,
	}

	sw.Do("func init() { localSchemeBuilder.Register(RegisterValidations)}\n\n", nil)

	sw.Do("// RegisterValidations adds validation functions to the given scheme.\n", nil)
	sw.Do("// Public to allow building arbitrary schemes.\n", nil)
	sw.Do("func RegisterValidations(scheme $.|raw$) error {\n", schemePtr)
	for _, rootType := range g.rootTypes {
		if !g.hasValidations(g.discovered.typeNodes[rootType]) {
			continue
		}

		node := g.discovered.typeNodes[rootType]
		if node == nil {
			panic(fmt.Sprintf("found nil node for root-type %v", rootType))
		}

		// TODO: It would be nice if these were not hard-coded.
		var statusType *types.Type
		var statusField string
		if status := node.lookupField("status"); status != nil {
			statusType = status.node.valueType
			statusField = status.name
		}

		targs := generator.Args{
			"rootType":    rootType,
			"typePfx":     "",
			"statusType":  statusType,
			"statusField": statusField,
			"field":       mkSymbolArgs(c, fieldPkgSymbols),
			"fmt":         mkSymbolArgs(c, fmtPkgSymbols),
			"operation":   mkSymbolArgs(c, operationPkgSymbols),
			"safe":        mkSymbolArgs(c, safePkgSymbols),
		}
		if !isNilableType(rootType) {
			targs["typePfx"] = "*"
		}

		// This uses a typed nil pointer, rather than a real instance because
		// we need the type information, but not an instance of the type.
		sw.Do("scheme.AddValidationFunc(", targs)
		sw.Do("    ($.typePfx$$.rootType|raw$)(nil), ", targs)
		sw.Do("    func(opCtx $.operation.Context|raw$, obj, oldObj interface{}, ", targs)
		sw.Do("    subresources ...string) $.field.ErrorList|raw$ {\n", targs)
		sw.Do("  if len(subresources) == 0 {\n", targs)
		sw.Do("    return $.rootType|objectvalidationfn$(", targs)
		sw.Do("               opCtx, ", targs)
		sw.Do("               obj.($.typePfx$$.rootType|raw$), ", targs)
		sw.Do("               $.safe.Cast|raw$[$.typePfx$$.rootType|raw$](oldObj), ", targs)
		sw.Do("               nil)\n", targs)
		sw.Do("  }\n", targs)

		if statusType != nil {
			targs["statusTypePfx"] = ""
			targs["statusTypePtrPfx"] = ""
			if !isNilableType(statusType) {
				targs["statusTypePfx"] = "*"
				targs["statusTypePtrPfx"] = "&"
			}
			sw.Do("  if len(subresources) == 1 && subresources[0] == \"status\" {\n", targs)
			if g.hasValidations(g.discovered.typeNodes[statusType]) {
				sw.Do("    root := obj.($.typePfx$$.rootType|raw$)\n", targs)
				sw.Do("    return $.statusType|objectvalidationfn$(", targs)
				sw.Do("               opCtx, ", targs)
				sw.Do("               &root.$.statusField$, ", targs)
				sw.Do("               $.safe.Field|raw$(", targs)
				sw.Do("                   $.safe.Cast|raw$[$.typePfx$$.rootType|raw$](oldObj), ", targs)
				sw.Do("                   func(oldObj $.typePfx$$.rootType|raw$) $.statusTypePfx$$.statusType|raw$ { return $.statusTypePtrPfx$oldObj.$.statusField$ }), ", targs)
				sw.Do("                   nil)\n", targs)
			} else {
				sw.Do("    return nil // $.statusType|raw$ has no validation\n", targs)
			}
			sw.Do("  }\n", targs)
		}
		sw.Do("  return $.field.ErrorList|raw${", targs)
		sw.Do("      $.field.InternalError|raw$(", targs)
		sw.Do("          nil, ", targs)
		sw.Do("          $.fmt.Errorf|raw$(\"no validation found for %T, subresources: %v\", obj, subresources))", targs)
		sw.Do("  }\n", targs)
		sw.Do("})\n", targs)
	}
	sw.Do("return nil\n", nil)
	sw.Do("}\n\n", nil)
}

// emitValidationFunction emits a validation function for the specified type.
func (g *genValidations) emitValidationFunction(c *generator.Context, t *types.Type, sw *generator.SnippetWriter) {
	if !g.hasValidations(g.discovered.typeNodes[t]) {
		return
	}

	targs := generator.Args{
		"inType":     t,
		"field":      mkSymbolArgs(c, fieldPkgSymbols),
		"operation":  mkSymbolArgs(c, operationPkgSymbols),
		"objTypePfx": "*",
	}
	if isNilableType(t) {
		targs["objTypePfx"] = ""
	}

	node := g.discovered.typeNodes[t]
	if node == nil {
		panic(fmt.Sprintf("found nil node for root-type %v", t))
	}
	sw.Do("func $.inType|objectvalidationfn$(", targs)
	sw.Do("    opCtx $.operation.Context|raw$, ", targs)
	sw.Do("    obj, oldObj $.objTypePfx$$.inType|raw$, ", targs)
	sw.Do("    fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
	fakeChild := &childNode{
		node:      node,
		childType: t,
	}
	g.emitValidationForChild(c, fakeChild, sw)
	sw.Do("return errs\n", nil)
	sw.Do("}\n\n", nil)
}

// emitNonIncludedTypeComment emits a comment explaining that the specified
// type is not being generated for.
func emitNonIncludedTypeComment(t *types.Type, sw *generator.SnippetWriter) {
	targs := generator.Args{
		"type": t,
	}
	sw.Do("// NOTE: Type $.type|raw$ is in a non-included package.\n", targs)
	sw.Do("//       Any validations defined on this type are not available from here.\n", targs)
}

// emitValidationForChild emits code for the specified childNode, calling
// type-attached validations and then descending into the type (e.g. struct
// fields).
//
// Emitted code assumes that the value in question is always a pair of nilable
// variables named "obj" and "oldObj", and the field path to this value is
// named "fldPath".
//
// This function assumes that thisChild.node is not nil.
func (g *genValidations) emitValidationForChild(c *generator.Context, thisChild *childNode, sw *generator.SnippetWriter) {
	thisNode := thisChild.node
	inType := thisNode.valueType

	targs := generator.Args{
		"inType": inType,
		"field":  mkSymbolArgs(c, fieldPkgSymbols),
		"safe":   mkSymbolArgs(c, safePkgSymbols),
	}

	didSome := false // for prettier output later

	// Emit code for type-attached validations.
	if validations := thisNode.typeValidations; !validations.Empty() {
		sw.Do("// type $.inType|raw$\n", targs)
		emitCallsToValidators(c, validations.Functions, sw)
		emitComments(validations.Comments, sw)
		sw.Do("\n", nil)
		didSome = true
	}

	// Descend into the type.
	switch inType.Kind {
	case types.Builtin:
		// Nothing further.
	case types.Alias:
		g.emitValidationForChild(c, thisNode.underlying, sw)
	case types.Struct:
		for _, fld := range thisNode.fields {
			if len(fld.name) == 0 {
				panic(fmt.Sprintf("missing field name in type %s (field-type %s)", thisNode.valueType, fld.childType))
			}
			// Missing JSON name is checked iff we have code to emit.

			// Accumulate into a buffer so we don't emit empty functions.
			buf := bytes.NewBuffer(nil)
			bufsw := sw.Dup(buf)

			validations := fld.fieldValidations
			if !validations.Empty() {
				emitCallsToValidators(c, validations.Functions, bufsw)
				emitComments(validations.Comments, bufsw)
			}

			// NOTE: while we don't know for sure that this field is a struct,
			// we can trust that if it has subfieldValidations, it probably is.
			// We have to do this here because we might be doing a subfield of
			// a non-included type (where the node is nil).
			for _, subchild := range fld.subfieldValidations {
				if len(subchild.name) == 0 {
					panic(fmt.Sprintf("missing child name for field in %v", thisNode))
				}
				if len(subchild.jsonName) == 0 {
					panic(fmt.Sprintf("missing child JSON name for field %v.%s", thisNode, subchild.name))
				}

				leafType, typePfx, exprPfx := getLeafTypeAndPrefixes(subchild.childType)
				targs := targs.WithArgs(generator.Args{
					"inType":       fld.childType,
					"fieldName":    subchild.name,
					"fieldJSON":    subchild.jsonName,
					"fieldType":    leafType,
					"fieldTypePfx": typePfx,
					"fieldExprPfx": exprPfx,
				})
				if fld.childType.Kind == types.Pointer {
					targs["inType"] = fld.childType.Elem
				}
				bufsw.Do("// field $.inType|raw$.$.fieldName$\n", targs)
				bufsw.Do("errs = append(errs,\n", targs)
				bufsw.Do("  func(obj, oldObj $.fieldTypePfx$$.fieldType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)

				if subchild.fieldValidations.Empty() {
					panic(fmt.Sprintf("found non-empty field validations in node.subfield for node: %v", subchild))
				}

				emitCallsToValidators(c, subchild.fieldValidations.Functions, bufsw)
				emitComments(subchild.fieldValidations.Comments, bufsw)

				bufsw.Do("    return\n", targs)
				bufsw.Do("  }($.fieldExprPfx$obj.$.fieldName$, $.safe.Field|raw$(oldObj, func(oldObj *$.inType|raw$) $.fieldTypePfx$$.fieldType|raw$ { return $.fieldExprPfx$oldObj.$.fieldName$ }), fldPath.Child(\"$.fieldJSON$\"))...)\n", targs)
				bufsw.Do("\n", nil)
			}

			// If the node is nil, this must be a type in a package we are not
			// handling - it's effectively opaque to us.
			if fld.node == nil {
				emitNonIncludedTypeComment(fld.childType, bufsw)
			} else {
				// Get to the real type.
				switch fld.node.valueType.Kind {
				case types.Alias:
					// Emit for the underlying type.
					g.emitValidationForChild(c, fld.node.underlying, bufsw)
					// Call the type's validation function.
					g.emitCallToOtherTypeFunc(c, fld.node, bufsw)
				case types.Struct:
					// Call the type's validation function.
					g.emitCallToOtherTypeFunc(c, fld.node, bufsw)
				default:
					// Descend into this field.
					g.emitValidationForChild(c, fld, bufsw)
				}
			}

			if buf.Len() > 0 {
				if len(fld.jsonName) == 0 {
					continue // TODO: Embedded (inline) types are expected to be unnamed.
				}

				leafType, typePfx, exprPfx := getLeafTypeAndPrefixes(fld.childType)
				targs := targs.WithArgs(generator.Args{
					"fieldName":    fld.name,
					"fieldJSON":    fld.jsonName,
					"fieldType":    leafType,
					"fieldTypePfx": typePfx,
					"fieldExprPfx": exprPfx,
				})

				if didSome {
					sw.Do("\n", nil)
				}
				sw.Do("// field $.inType|raw$.$.fieldName$\n", targs)
				sw.Do("errs = append(errs,\n", targs)
				sw.Do("  func(obj, oldObj $.fieldTypePfx$$.fieldType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
				sw.Append(buf)
				sw.Do("    return\n", targs)
				sw.Do("  }($.fieldExprPfx$obj.$.fieldName$, ", targs)
				sw.Do("    $.safe.Field|raw$(oldObj, ", targs)
				sw.Do("        func(oldObj *$.inType|raw$) $.fieldTypePfx$$.fieldType|raw$ {", targs)
				sw.Do("            return $.fieldExprPfx$oldObj.$.fieldName$", targs)
				sw.Do("        }),", targs)
				sw.Do("    fldPath.Child(\"$.fieldJSON$\"))...)\n", targs)
				sw.Do("\n", nil)
			} else {
				targs := targs.WithArgs(generator.Args{
					"fieldName": fld.name,
				})
				sw.Do("// field $.inType|raw$.$.fieldName$ has no validation\n", targs)
			}
			didSome = true
		}
	case types.Slice, types.Array:
		// Accumulate into a buffer so we don't emit empty functions.
		elemBuf := bytes.NewBuffer(nil)
		elemSW := sw.Dup(elemBuf)

		// Validate each value.
		validations := thisNode.elemValidations
		validations.Add(thisChild.elemValidations)
		if !validations.Empty() {
			emitCallsToValidators(c, validations.Functions, elemSW)
			emitComments(validations.Comments, elemSW)
		}

		// If the node is nil, this must be a type in a package we are not
		// handling - it's effectively opaque to us.
		if thisNode.elem.node == nil {
			emitNonIncludedTypeComment(thisNode.elem.childType, elemSW)
		} else {
			switch thisNode.elem.node.valueType.Kind {
			case types.Struct, types.Alias:
				// If this field is another type, call its validation function.
				// Checking for nil is handled inside this call.
				g.emitCallToOtherTypeFunc(c, thisNode.elem.node, elemSW)
			default:
				// No need to go further.  Struct- or alias-typed fields might have
				// validations attached to the type, but anything else (e.g.
				// string) can't, and we already emitted code for the field
				// validations.
			}
		}

		if elemBuf.Len() > 0 {
			leafType, typePfx, exprPfx := getLeafTypeAndPrefixes(inType.Elem)
			targs := targs.WithArgs(generator.Args{
				"elemType":    leafType,
				"elemTypePfx": typePfx,
				"elemExprPfx": exprPfx,
			})

			isCorrelatable := len(thisNode.listMapKeys) > 0
			oldVal := "nil" // updated below if needed

			// Lookup corresponding old slice elem values for update validation using a traverse.ListMap.
			// Only +k8s:listType=map slices have corresponding old values. Corresponding old values have matching
			// +k8s:listMapKey values.
			if isCorrelatable {
				// Note: this func returns 'any' but it's always an array (not
				// slice) of 'any', and those should always be comparable, so
				// we should not see runtime errors ("comparing uncomparable
				// type").
				sw.Do("oldListMap := $.safe.NewListMap|raw$(oldObj, func(o $.elemTypePfx$$.elemType|raw$) any {", targs)
				sw.Do(" return ", targs)
				emitListMapKey(sw, "o", thisNode)
				sw.Do("})\n", targs)
				oldVal = "oldListMap.WithMatchingKey(val)"
			}
			targs["oldVal"] = oldVal

			sw.Do("for i, val := range obj {\n", targs)
			sw.Do("  errs = append(errs,\n", targs)
			sw.Do("    func(obj, oldObj $.elemTypePfx$$.elemType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
			sw.Append(elemBuf)
			sw.Do("      return\n", targs)
			sw.Do("    }($.elemExprPfx$val, $.oldVal$, fldPath.Index(i))...)\n", targs)
			sw.Do("}\n", nil)
		}
	case types.Map:
		// Accumulate into a buffer so we don't emit empty functions.
		keyBuf := bytes.NewBuffer(nil)
		keySW := sw.Dup(keyBuf)

		// Validate each key.
		keyValidations := thisNode.keyValidations
		keyValidations.Add(thisChild.keyValidations)
		if !keyValidations.Empty() {
			emitCallsToValidators(c, keyValidations.Functions, keySW)
			emitComments(keyValidations.Comments, keySW)
		}

		// If the node is nil, this must be a type in a package we are not
		// handling - it's effectively opaque to us.
		if thisNode.key.node == nil {
			emitNonIncludedTypeComment(thisNode.key.childType, keySW)
		} else {
			switch thisNode.key.node.valueType.Kind {
			case types.Struct, types.Alias:
				// If this field is another type, call its validation function.
				// Checking for nil is handled inside this call.
				g.emitCallToOtherTypeFunc(c, thisNode.key.node, keySW)
			default:
				// No need to go further.  Struct- or alias-typed fields might have
				// validations attached to the type, but anything else (e.g.
				// string) can't, and we already emitted code for the field
				// validations.
			}
		}

		// Accumulate into a buffer so we don't emit empty functions.
		valBuf := bytes.NewBuffer(nil)
		valSW := sw.Dup(valBuf)

		// Validate each value.
		valValidations := thisNode.elemValidations
		valValidations.Add(thisChild.elemValidations)
		if !valValidations.Empty() {
			emitCallsToValidators(c, valValidations.Functions, valSW)
			emitComments(valValidations.Comments, valSW)
		}

		// If the node is nil, this must be a type in a package we are not
		// handling - it's effectively opaque to us.
		if thisNode.elem.node == nil {
			emitNonIncludedTypeComment(thisNode.elem.childType, valSW)
		} else {
			switch thisNode.elem.node.valueType.Kind {
			case types.Struct, types.Alias:
				// If this field is another type, call its validation function.
				// Checking for nil is handled inside this call.
				g.emitCallToOtherTypeFunc(c, thisNode.elem.node, valSW)
			default:
				// No need to go further.  Struct- or alias-typed fields might have
				// validations attached to the type, but anything else (e.g.
				// string) can't, and we already emitted code for the field
				// validations.
			}
		}

		vName := "_"
		if valBuf.Len() > 0 {
			vName = "val"
		}
		if keyBuf.Len()+valBuf.Len() > 0 {
			valLeafType, valTypePfx, valExprPfx := getLeafTypeAndPrefixes(inType.Elem)
			targs := targs.WithArgs(generator.Args{
				"keyType":    inType.Key, // we only handle ~string keys
				"valType":    valLeafType,
				"valTypePfx": valTypePfx,
				"valExprPfx": valExprPfx,
			})
			if !isNilableType(inType.Elem) {
				// E.g. map[string]StructType => *StructType
				targs["xform"] = targs["safe"].(generator.Args)["PtrTo"]
			} else if inType.Elem.Kind == types.Pointer && isNilableType(inType.Elem.Elem) {
				// E.g. given type E []StructType, map[string]*E => E
				targs["xform"] = targs["safe"].(generator.Args)["Deref"]
			} else {
				// E.g. map[string]*StructType => StructType
				targs["xform"] = targs["safe"].(generator.Args)["Ident"]
			}

			sw.Do("for key, $.val$ := range obj {\n", targs.With("val", vName))
			if keyBuf.Len() > 0 {
				sw.Do("  errs = append(errs,\n", targs)
				sw.Do("    func(obj, oldObj *$.keyType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
				sw.Append(keyBuf)
				sw.Do("      return\n", targs)
				sw.Do("    }(&key, nil, fldPath)...)\n", targs) // We don't match up map keys with a corresponding old value
			}
			if valBuf.Len() > 0 {
				sw.Do("  errs = append(errs,\n", targs)
				sw.Do("    func(obj, oldObj $.valTypePfx$$.valType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
				sw.Append(valBuf)
				sw.Do("      return\n", targs)
				sw.Do("    }($.valExprPfx$val, $.safe.Lookup|raw$(oldObj, key, $.xform|raw$), fldPath.Key(string(key)))...)\n", targs)
			}

			sw.Do("}\n", nil)
		}
	default:
		panic(fmt.Sprintf("unhandled type: %v (kind %s)", inType, inType.Kind))
	}
}

// emitListMapKey emits an arrays of key fields values representing the key of a listType=map typeNode.
// The emitted array can be used as a go map key. An array is used instead of a slice because slices
// may not be used as map keys in go.
func emitListMapKey(sw *generator.SnippetWriter, varName string, node *typeNode) {
	targs := generator.Args{
		"varName":     varName,
		"memberCount": len(node.listMapKeys),
	}
	sw.Do("[$.memberCount$]any{", targs)
	for i, member := range node.listMapKeys {
		targs["member"] = member.Name
		sw.Do("$.varName$.$.member$", targs)
		if i < len(node.listMapKeys)-1 {
			sw.Do(",  ", nil)
		}
	}
	sw.Do("}", targs)
}

// emitCallToOtherTypeFunc generates a call to the specified node's generated
// validation function for a field in some parent context.
//
// Emitted code assumes that the value in question is always a pair of nilable
// variables named "obj" and "oldObj", and the field path to this value is
// named "fldPath".
func (g *genValidations) emitCallToOtherTypeFunc(c *generator.Context, node *typeNode, sw *generator.SnippetWriter) {
	// If this type has no validations (transitively) then we don't need to do
	// anything.
	if !g.hasValidations(node) {
		return
	}

	targs := generator.Args{
		"funcName": c.Universe.Type(node.funcName),
	}
	sw.Do("errs = append(errs, $.funcName|raw$(opCtx, obj, oldObj, fldPath)...)\n", targs)
}

// emitCallsToValidators emits calls to a list of validation functions for
// a single field or type. validations is a list of functions to call, with
// arguments.
//
// When calling registered validators, we always pass a nilable type.  E.g. if
// the field's type is string, we pass *string, and if the field's type is
// *string, we also pass *string.  This means that validators need to do
// nil-checks themselves, if they intend to dereference the pointer.  This
// makes updates more consistent.
//
// Emitted code assumes that the value in question is always a pair of nilable
// variables named "obj" and "oldObj", and the field path to this value is
// named "fldPath".
func emitCallsToValidators(c *generator.Context, validations []validators.FunctionGen, sw *generator.SnippetWriter) {
	// Helper func
	sort := func(in []validators.FunctionGen) []validators.FunctionGen {
		sooner := make([]validators.FunctionGen, 0, len(in))
		later := make([]validators.FunctionGen, 0, len(in))

		for _, fg := range in {
			isShortCircuit := (fg.Flags().IsSet(validators.ShortCircuit))

			if isShortCircuit {
				sooner = append(sooner, fg)
			} else {
				later = append(later, fg)
			}
		}
		result := sooner
		result = append(result, later...)
		return result
	}

	validations = sort(validations)

	for _, v := range validations {
		isShortCircuit := v.Flags().IsSet(validators.ShortCircuit)
		isNonError := v.Flags().IsSet(validators.NonError)

		fn, extraArgs := v.SignatureAndArgs()
		targs := generator.Args{
			"funcName": c.Universe.Type(fn),
			"field":    mkSymbolArgs(c, fieldPkgSymbols),
		}

		emitCall := func() {
			sw.Do("$.funcName|raw$", targs)
			typeArgs := v.TypeArgs()
			if len(typeArgs) > 0 {
				sw.Do("[", nil)
				for i, typeArg := range typeArgs {
					sw.Do("$.|raw$", c.Universe.Type(typeArg))
					if i < len(typeArgs)-1 {
						sw.Do(",", nil)
					}
				}
				sw.Do("]", nil)
			}
			sw.Do("(opCtx, fldPath, obj, oldObj", targs)
			for _, arg := range extraArgs {
				sw.Do(", ", nil)
				toGolangSourceDataLiteral(sw, c, arg)
			}
			sw.Do(")", targs)
		}

		// If validation is conditional, wrap the validation function with a conditions check.
		if !v.Conditions().Empty() {
			emitBaseFunction := emitCall
			emitCall = func() {
				sw.Do("func() $.field.ErrorList|raw$ {\n", targs)
				sw.Do("  if ", nil)
				firstCondition := true
				if len(v.Conditions().OptionEnabled) > 0 {
					sw.Do("opCtx.Options.Has($.$)", strconv.Quote(v.Conditions().OptionEnabled))
					firstCondition = false
				}
				if len(v.Conditions().OptionDisabled) > 0 {
					if !firstCondition {
						sw.Do(" && ", nil)
					}
					sw.Do("!opCtx.Options.Has($.$)", strconv.Quote(v.Conditions().OptionDisabled))
				}
				sw.Do(" {\n", nil)
				sw.Do("    return ", nil)
				emitBaseFunction()
				sw.Do("\n", nil)
				sw.Do("  } else {\n", nil)
				sw.Do("    return nil // skip validation\n", nil)
				sw.Do("  }\n", nil)
				sw.Do("}()", nil)
			}
		}

		if isShortCircuit {
			sw.Do("if e := ", nil)
			emitCall()
			sw.Do("; len(e) != 0 {\n", nil)
			if !isNonError {
				sw.Do("errs = append(errs, e...)\n", nil)
			}
			sw.Do("    return // do not proceed\n", nil)
			sw.Do("}\n", nil)
		} else {
			if isNonError {
				emitCall()
			} else {
				sw.Do("errs = append(errs, ", nil)
				emitCall()
				sw.Do("...)\n", nil)
			}
		}
	}
}

func emitComments(comments []string, sw *generator.SnippetWriter) {
	for _, comment := range comments {
		sw.Do("// ", nil)
		sw.Do(comment, nil)
		sw.Do("\n", nil)
	}
}

// emitValidationVariables emits a list of variable declarations. Each variable declaration has a
// private (unexported) variable name, and a function invocation declaration that is expected
// to initialize the value of the variable.
func (g *genValidations) emitValidationVariables(c *generator.Context, t *types.Type, sw *generator.SnippetWriter) {
	tn := g.discovered.typeNodes[t]

	variables := tn.typeValidations.Variables
	slices.SortFunc(variables, func(a, b validators.VariableGen) int {
		return cmp.Compare(a.Var().Name, b.Var().Name)
	})
	for _, variable := range variables {
		supportInitFn, supportInitArgs := variable.Init().SignatureAndArgs()
		targs := generator.Args{
			"varName": c.Universe.Type(types.Name(variable.Var())),
			"initFn":  c.Universe.Type(supportInitFn),
		}
		sw.Do("var $.varName|private$ = $.initFn|raw$", targs)
		typeArgs := variable.Init().TypeArgs()
		if len(typeArgs) > 0 {
			sw.Do("[", nil)
			for i, typeArg := range typeArgs {
				sw.Do("$.|raw$", c.Universe.Type(typeArg))
				if i < len(typeArgs)-1 {
					sw.Do(",", nil)
				}
			}
			sw.Do("]", nil)
		}
		sw.Do("(", targs)
		for i, arg := range supportInitArgs {
			toGolangSourceDataLiteral(sw, c, arg)
			if i < len(supportInitArgs)-1 {
				sw.Do(", ", nil)
			}
		}
		sw.Do(")\n", nil)

	}
}

func toGolangSourceDataLiteral(sw *generator.SnippetWriter, c *generator.Context, value any) {
	// For safety, be strict in what values we output to visited source, and ensure strings
	// are quoted.

	switch v := value.(type) {
	case uint, uint8, uint16, uint32, uint64, int, int8, int16, int32, int64, float32, float64, bool:
		sw.Do(fmt.Sprintf("%v", value), nil)
	case string:
		// If the incoming string was quoted, we still do it ourselves, JIC.
		str := value.(string)
		if s, err := strconv.Unquote(str); err == nil {
			str = s
		}
		sw.Do(fmt.Sprintf("%q", str), nil)
	case *types.Type:
		sw.Do("$.|raw$", v)
	case types.Member:
		sw.Do("obj."+v.Name, nil)
	case validators.Identifier:
		sw.Do("$.|raw$", c.Universe.Type(types.Name(v)))
	case *validators.Identifier:
		sw.Do("$.|raw$", c.Universe.Type(types.Name(*v)))
	case validators.PrivateVar:
		sw.Do("$.|private$", c.Universe.Type(types.Name(v)))
	case *validators.PrivateVar:
		sw.Do("$.|private$", c.Universe.Type(types.Name(*v)))
	default:
		rv := reflect.ValueOf(value)
		switch rv.Kind() {
		case reflect.Slice, reflect.Array:
			arraySize := ""
			if rv.Kind() == reflect.Array {
				arraySize = strconv.Itoa(rv.Len())
			}
			var itemType string
			switch rv.Type().Elem().Kind() {
			case reflect.String: // For now, only support lists of strings.
				itemType = rv.Type().Elem().Name()
			default:
				panic(fmt.Sprintf("Unsupported extraArg type: %T", value))
			}
			rv.Type().Elem()
			sw.Do("[$.arraySize$]$.itemType${", map[string]string{"arraySize": arraySize, "itemType": itemType})
			for i := 0; i < rv.Len(); i++ {
				val := rv.Index(i)
				toGolangSourceDataLiteral(sw, c, val.Interface())
				if i < rv.Len()-1 {
					sw.Do(", ", nil)
				}
			}
			sw.Do("}", nil)
		default:
			// TODO: check this during discovery and emit an error with more useful information
			panic(fmt.Sprintf("Unsupported extraArg type: %T", value))
		}
	}
}

// extractListMapKeys looks at all fields of the specified type to find the
// fields which match the specified keyNames, and returns a list of Member
// structs.  If t is not a struct this does nothing.
func extractListMapKeys(t *types.Type, keyNames []string) ([]types.Member, error) {
	var result []types.Member
	for _, name := range keyNames {
		m, found := findMemberByFieldName(t, name)
		if !found {
			return nil, fmt.Errorf("list-map key %q refers to a field that does not exist", name)
		}
		result = append(result, m)
	}
	return result, nil
}

// findMemberByFieldName finds the member which matches the specified name.
// The name is expected to be the "JSON name", rather than the Go name.  This
// function will descend into embedded types which would appear in JSON to be
// directly in the parent struct.  If t is not a struct this does nothing.
func findMemberByFieldName(t *types.Type, name string) (types.Member, bool) {
	for _, m := range t.Members {
		if jsonTag, found := tags.LookupJSON(m); found {
			// If there is a JSON tag of the exact name, use it.
			if jsonTag.Name == name {
				return m, true
			}
			// If there is a (non-standard) "inline" tag, look in the type.
			if jsonTag.Inline {
				return findMemberByFieldName(m.Type, name)
			}
		}
		// If this field was embedded, look in that type.
		if m.Embedded {
			return findMemberByFieldName(m.Type, name)
		}
	}
	return types.Member{}, false
}

// isNilableType returns true if the argument type can be compared to nil.
func isNilableType(t *types.Type) bool {
	for t.Kind == types.Alias {
		t = t.Underlying
	}
	switch t.Kind {
	case types.Pointer, types.Map, types.Slice, types.Interface: // Note: Arrays are not nilable
		return true
	}
	return false
}

// getLeafTypeAndPrefixes returns the "leaf value type" for a given type, as
// well as type and expression prefix strings for the input type.  The type
// prefix can be prepended to the given type's name to produce the nilable form
// of that type.  The expression prefix can be prepended to a variable of the
// given type to produce the nilable form of that value.
//
// Example: Given an input type "string" this should produce (string, "*", "&").
// That is to say: the value-type is "string", which yields "*string" when the
// type prefix is applied, and a variable "x" becomes "&x" when the expression
// prefix is applied.
//
// Example: Given an input type "*string" this should produce (string, "*", "").
// That is to say: the value-type is "string", which yields "*string" when the
// type prefix is applied, and a variable "x" remains "x" when the expression
// prefix is applied.
func getLeafTypeAndPrefixes(inType *types.Type) (*types.Type, string, string) {
	leafType := inType
	typePfx := ""
	exprPfx := ""

	nPtrs := 0
	for leafType.Kind == types.Pointer {
		nPtrs++
		leafType = leafType.Elem
	}
	if !isNilableType(leafType) {
		typePfx = "*"
		if nPtrs == 0 {
			exprPfx = "&"
		} else {
			exprPfx = strings.Repeat("*", nPtrs-1)
		}
	} else {
		exprPfx = strings.Repeat("*", nPtrs)
	}

	return leafType, typePfx, exprPfx
}

// FixtureTests generates a test file that checks all validateFalse validations.
func FixtureTests(outputFilename string, testFixtureTags sets.Set[string]) generator.Generator {
	return &fixtureTestGen{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename,
		},
		testFixtureTags: testFixtureTags,
	}
}

type fixtureTestGen struct {
	generator.GoGenerator
	testFixtureTags sets.Set[string]
}

func (g *fixtureTestGen) Imports(_ *generator.Context) (imports []string) {
	return []string{`"testing"`}
}

func (g *fixtureTestGen) Init(c *generator.Context, w io.Writer) error {
	if g.testFixtureTags.Has("validateFalse") {
		sw := generator.NewSnippetWriter(w, c, "$", "$")
		sw.Do("func TestValidation(t *testing.T) {\n", nil)
		sw.Do("  localSchemeBuilder.Test(t).ValidateFixtures()\n", nil)
		sw.Do("}\n", nil)
	}
	return nil
}

// extractSubfieldValidations extracts all +k8s:subfield validations for the given
// subfield that were defined on the parent struct.The syntax for the tag is
// +k8s:subfield(subfield-json-name)=<validator-tag>=<args>
// TODO: this could be supported on type definitions.
func (td *typeDiscoverer) extractSubfieldValidations(context validators.Context, jsonName string, comments []string) (validators.Validations, error) {
	var result validators.Validations

	// Currently the format for +k8s:subfield tag is:
	// +k8s:subfield(subfield-json-name)=<validator-tag>=<args> validator tag args..."
	fieldTag := fmt.Sprintf("%s(%s)", subfieldTag, jsonName)
	if tagVals, found := gengo.ExtractCommentTags("+", comments)[fieldTag]; found {
		for _, tagVal := range tagVals {
			// Extract any embedded validation rules.
			fakeComments := []string{tagVal}
			if subfieldValidations, err := td.validatorRegistry.ExtractValidations(context, fakeComments); err != nil {
				return result, err
			} else {
				if !subfieldValidations.Empty() {
					result.Add(subfieldValidations)
				}
			}
			//legacy
			if subfieldValidations, err := td.validator.ExtractValidations(context.Type, fakeComments); err != nil {
				return result, err
			} else {
				if !subfieldValidations.Empty() {
					result.Add(subfieldValidations)
				}
			}
		}
	}
	return result, nil
}

// forEachField iterates over each exported field of the given type,
// and performs the given operation.
func forEachField(t *types.Type, op func(member types.Member, name, jsonName string) error) error {
	for _, memb := range t.Members {
		name := memb.Name
		if len(name) == 0 { // embedded fields
			if memb.Type.Kind == types.Pointer {
				name = memb.Type.Elem.Name.Name
			} else {
				name = memb.Type.Name.Name
			}
		}
		// Only do exported fields.
		if unicode.IsLower([]rune(name)[0]) {
			continue
		}

		// If we try to emit code for this field and find no JSON name, we
		// will abort.
		jsonName := ""
		if commentTags, ok := tags.LookupJSON(memb); ok {
			jsonName = commentTags.Name
		}

		if err := op(memb, name, jsonName); err != nil {
			return err
		}
	}
	return nil
}
