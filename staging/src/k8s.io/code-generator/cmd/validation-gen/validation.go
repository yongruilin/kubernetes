/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bytes"
	"cmp"
	"fmt"
	"io"
	"reflect"
	"slices"
	"strconv"
	"strings"
	"unicode"

	"k8s.io/apimachinery/pkg/util/validation/field"
	"k8s.io/code-generator/cmd/validation-gen/validators"
	"k8s.io/gengo/v2"
	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/parser/tags"
	"k8s.io/gengo/v2/types"
	"k8s.io/klog/v2"
)

func mkPkgNames(pkg string, names ...string) []types.Name {
	result := make([]types.Name, 0, len(names))
	for _, name := range names {
		result = append(result, types.Name{Package: pkg, Name: name})
	}
	return result
}

var (
	fieldPkg            = "k8s.io/apimachinery/pkg/util/validation/field"
	fieldPkgSymbols     = mkPkgNames(fieldPkg, "ErrorList", "InternalError", "Path")
	fmtPkgSymbols       = mkPkgNames("fmt", "Errorf")
	safePkg             = "k8s.io/apimachinery/pkg/api/safe"
	safePkgSymbols      = mkPkgNames(safePkg, "NewListMap", "Field", "Lookup", "Cast", "PtrTo", "Deref", "Ident")
	operationPkg        = "k8s.io/apimachinery/pkg/api/operation"
	operationPkgSymbols = mkPkgNames(operationPkg, "Context", "Update")
)

// genValidations produces a file with autogenerated validations.
type genValidations struct {
	generator.GoGenerator
	outputPackage       string
	inputToPkg          map[string]string // Maps input packages to generated validation packages
	rootTypes           []*types.Type
	discovered          *typeDiscoverer
	imports             namer.ImportTracker
	validator           validators.DeclarativeValidator
	hasValidationsCache map[*typeNode]bool
	schemaRegistry      types.Name
}

// NewGenValidations cretes a new generator for the specified package.
func NewGenValidations(outputFilename, outputPackage string, rootTypes []*types.Type, discovered *typeDiscoverer, inputToPkg map[string]string, validator validators.DeclarativeValidator, schemaRegistry types.Name) generator.Generator {
	return &genValidations{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename,
		},
		outputPackage:       outputPackage,
		inputToPkg:          inputToPkg,
		rootTypes:           rootTypes,
		discovered:          discovered,
		imports:             generator.NewImportTrackerForPackage(outputPackage),
		validator:           validator,
		hasValidationsCache: map[*typeNode]bool{},
		schemaRegistry:      schemaRegistry,
	}
}

func (g *genValidations) Namers(_ *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.outputPackage, g.imports),
	}
}

func (g *genValidations) Filter(_ *generator.Context, t *types.Type) bool {
	// We want to emit code for all root types.
	for _, rt := range g.rootTypes {
		if rt == t {
			return true
		}
	}
	// We want to emit for any other type that is transitively part of a root
	// type and has validations.
	n := g.discovered.typeNodes[t]
	return n != nil && g.hasValidations(n)
}

func (g *genValidations) Imports(_ *generator.Context) (imports []string) {
	var importLines []string
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}

func (g *genValidations) isOtherPackage(pkg string) bool {
	if pkg == g.outputPackage {
		return false
	}
	if strings.HasSuffix(pkg, `"`+g.outputPackage+`"`) {
		return false
	}
	return true
}

func (g *genValidations) Init(c *generator.Context, w io.Writer) error {
	klog.V(5).Infof("emitting registration code")
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	g.emitRegisterFunction(c, g.schemaRegistry, sw)
	if err := sw.Error(); err != nil {
		return err
	}
	return nil
}

func (g *genValidations) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	klog.V(5).Infof("emitting validation code for type %v", t)

	sw := generator.NewSnippetWriter(w, c, "$", "$")
	g.emitValidationVariables(c, t, sw)
	g.emitValidationFunction(c, t, sw)
	if err := sw.Error(); err != nil {
		return err
	}
	return nil
}

func (g *genValidations) hasValidations(n *typeNode) bool {
	if r, found := g.hasValidationsCache[n]; found {
		return r
	}
	r := g.hasValidationsMiss(n)
	g.hasValidationsCache[n] = r
	return r
}

// Called in case of a cache miss.
func (g *genValidations) hasValidationsMiss(n *typeNode) bool {
	if !n.typeValidations.Empty() {
		return true
	}
	allChildren := n.fields
	if n.key != nil {
		allChildren = append(allChildren, n.key)
	}
	if n.elem != nil {
		allChildren = append(allChildren, n.elem)
	}
	for _, c := range allChildren {
		if !c.fieldValidations.Empty() || !c.keyValidations.Empty() || !c.elemValidations.Empty() {
			return true
		}
		if g.hasValidations(c.node) {
			return true
		}
	}
	return false
}

// typeDiscoverer contains fields necessary to build graphs of types.
type typeDiscoverer struct {
	validator  validators.DeclarativeValidator
	inputToPkg map[string]string

	// typeNodes holds a map of gengo Type to typeNode for all of the types
	// encountered during discovery.
	typeNodes map[*types.Type]*typeNode
}

// NewTypeDiscoverer creates and initializes a NewTypeDiscoverer.
func NewTypeDiscoverer(validator validators.DeclarativeValidator, inputToPkg map[string]string) *typeDiscoverer {
	return &typeDiscoverer{
		validator:  validator,
		inputToPkg: inputToPkg,
		typeNodes:  map[*types.Type]*typeNode{},
	}
}

// childNode represents a type which is used in another type (e.g. a struct
// field).
type childNode struct {
	name      string      // the field name in the parent, populated when this node is a struct field
	jsonName  string      // always populated when name is populated
	childType *types.Type // the real type of the child (may be a pointer)
	node      *typeNode   // the node of the child's value type

	fieldValidations validators.Validations // validations on the field
	keyValidations   validators.Validations // validations on each key of a map field
	elemValidations  validators.Validations // validations on each value of a list or map
}

// typeNode represents a node in the type-graph, annotated with information
// about validations.  Everything in this type, transitively, is assoctiated
// with the type, and not any specific instance of that type (e.g. when used as
// a field in a struct.
type typeNode struct {
	valueType *types.Type // never a pointer, but may be a map, slice, struct, etc.
	funcName  types.Name  // populated when this type is "opaque"

	fields      []*childNode   // populated when this type is a struct
	key         *childNode     // populated when this type is a map
	elem        *childNode     // populated when this type is a map or slice
	underlying  *childNode     // populated when this type is an alias
	listMapKeys []types.Member // populated with +listMapKey values when this type is a +listType=map slice

	typeValidations validators.Validations // validations on the type
	keyValidations  validators.Validations // validations on each key of a map type
	elemValidations validators.Validations // validations on each value of a list or map
}

// lookupField returns the childNode with the specified JSON name.
func (n typeNode) lookupField(jsonName string) *childNode {
	for _, fld := range n.fields {
		if fld.jsonName == jsonName {
			return fld
		}
	}
	return nil
}

// dump returns a multi-line string which represents a typeNode and its
// children.  This can be used to debug the type graph.
func (n *typeNode) dump() string {
	buf := bytes.Buffer{}
	visited := map[*typeNode]bool{}
	buf.WriteString(fmt.Sprintf("type %s {\n", n.valueType))
	n.doDump(&buf, 1, visited)
	buf.WriteString("}")
	return buf.String()
}

func (n *typeNode) dumpIndent(buf *bytes.Buffer, indent int) {
	for i := 0; i < indent; i++ {
		buf.WriteString("    ")
	}
}

func (n *typeNode) doDump(buf *bytes.Buffer, indent int, visited map[*typeNode]bool) {
	if visited[n] {
		n.dumpIndent(buf, indent)
		buf.WriteString("(recursive)\n")
		return
	}
	visited[n] = true

	for _, val := range n.typeValidations.Functions {
		n.dumpIndent(buf, indent)
		fn, args := val.SignatureAndArgs()
		buf.WriteString(fmt.Sprintf("type-validation: %v(%+v)\n", fn, args))
	}
	for _, val := range n.typeValidations.Variables {
		n.dumpIndent(buf, indent)
		fn, args := val.Init().SignatureAndArgs()
		buf.WriteString(fmt.Sprintf("type-validation variable: %s := %v(%+v)\n", val.Var().Name, fn, args))
	}
	n.dumpChildren(buf, indent, visited)
}

func (n *typeNode) dumpChildren(buf *bytes.Buffer, indent int, visited map[*typeNode]bool) {
	for _, fld := range n.fields {
		n.dumpIndent(buf, indent)
		buf.WriteString(fmt.Sprintf("field %s: %s {\n", fld.name, fld.childType))
		for _, val := range fld.fieldValidations.Functions {
			fn, args := val.SignatureAndArgs()
			n.dumpIndent(buf, indent+1)
			buf.WriteString(fmt.Sprintf("field-validation: %v(%+v)\n", fn, args))
		}
		for _, val := range fld.keyValidations.Functions {
			fn, args := val.SignatureAndArgs()
			n.dumpIndent(buf, indent+1)
			buf.WriteString(fmt.Sprintf("key-validation: %v(%+v)\n", fn, args))
		}
		for _, val := range fld.elemValidations.Functions {
			fn, args := val.SignatureAndArgs()
			n.dumpIndent(buf, indent+1)
			buf.WriteString(fmt.Sprintf("val-validation: %v(%+v)\n", fn, args))
		}
		fld.node.doDump(buf, indent+1, visited)
		n.dumpIndent(buf, indent)
		buf.WriteString("}\n")
	}
}

const (
	// This tag defines a validation which is to be run on each key in a map.
	eachKeyTag = "eachKey"
	// This tag defines a validation which is to be run on each value in a map
	// or slice.
	eachValTag = "eachVal"
)

// builtinTagDocs returns information about the hard-coded tags.
func builtinTagDocs() []validators.TagDoc {
	return []validators.TagDoc{{
		Tag:         eachKeyTag,
		Description: "Declares a validation for map keys.",
		Contexts:    []validators.TagContext{validators.TagContextType, validators.TagContextField},
		Payloads: []validators.TagPayloadDoc{{
			Description: "<validation-tag>",
			Docs:        "This tag will be evaluated for each key of a map.",
		}},
	}, {
		Tag:         eachValTag,
		Description: "Declares a validation for map and slice values.",
		Contexts:    []validators.TagContext{validators.TagContextType, validators.TagContextField},
		Payloads: []validators.TagPayloadDoc{{
			Description: "<validation-tag>",
			Docs:        "This tag will be evaluated for each value of a map or slice.",
		}},
	}}
}

// DiscoverType walks the given type recursively, building a type-graph in this
// typeDiscoverer.  If this is called multiple times for different types, the
// multiple graphs will be stored, and where types overlap, they will be
// merged.
func (td *typeDiscoverer) DiscoverType(t *types.Type) error {
	if t.Kind == types.Pointer {
		return fmt.Errorf("type %v: pointer root-types are not supported", t)
	}
	fldPath := field.NewPath(t.Name.String())
	if node, err := td.discover(t, fldPath); err != nil {
		return err
	} else {
		fmt.Println(node.dump()) //FIXME: remove
	}
	return nil
}

// discover walks the given type recursively and returns a typeNode
// representing it.
func (td *typeDiscoverer) discover(t *types.Type, fldPath *field.Path) (*typeNode, error) {
	if t.Kind == types.Pointer {
		if t.Elem.Kind == types.Pointer {
			return nil, fmt.Errorf("field %s (%s): pointers to pointers are not supported", fldPath.String(), t)
		}
		// Remove pointerness.
		t = t.Elem
	}
	// If we have done this type already, we can stop here and break any
	// recursion.
	if node := td.typeNodes[t]; node != nil {
		return node, nil
	}

	// If we are descending into a named type, reboot the field path for better
	// logging.  Otherwise the field path might come in as something like
	// <type1>.<field1>.<field2> which is true, but not super useful.
	switch t.Kind {
	case types.Alias, types.Struct:
		fldPath = field.NewPath(t.Name.String())
	}

	thisNode := &typeNode{
		valueType: t,
	}
	td.typeNodes[t] = thisNode

	// Extract any type-attached validation rules.
	if validations, err := td.validator.ExtractValidations(t, t.CommentLines); err != nil {
		return nil, fmt.Errorf("%v: %w", fldPath, err)
	} else {
		if !validations.Empty() {
			klog.V(5).InfoS("found type-attached validations", "n", validations.Len())
			thisNode.typeValidations = validations
		}
	}

	// If this is an opaque, named type, we can call its validation function.
	switch t.Kind {
	case types.Alias, types.Struct:
		if fn, ok := td.getValidationFunctionName(t); !ok {
			return thisNode, nil
		} else {
			thisNode.funcName = fn
		}
	}

	switch t.Kind {
	case types.Builtin:
		// Nothing more to do.
	case types.Alias:
		// Discover into this alias, recursively.
		if err := td.discoverAlias(thisNode, fldPath); err != nil {
			return nil, err
		}
	case types.Struct:
		// Discover into this struct, recursively.
		if err := td.discoverStruct(thisNode, fldPath); err != nil {
			return nil, err
		}
	case types.Slice, types.Array:
		// Discover the element type.
		if node, err := td.discover(t.Elem, fldPath.Key("vals")); err != nil {
			return nil, err
		} else {
			thisNode.elem = &childNode{
				childType: t.Elem,
				node:      node,
			}
		}
	case types.Map:
		// Discover the key type.
		if node, err := td.discover(t.Key, fldPath.Key("keys")); err != nil {
			return nil, err
		} else {
			thisNode.key = &childNode{
				childType: t.Key,
				node:      node,
			}
		}

		// Discover the element type.
		if node, err := td.discover(t.Elem, fldPath.Key("vals")); err != nil {
			return nil, err
		} else {
			thisNode.elem = &childNode{
				childType: t.Elem,
				node:      node,
			}
		}
	default:
		return nil, fmt.Errorf("field %s (%v, kind %v) is not supported", fldPath.String(), t, t.Kind)
	}

	return thisNode, nil
}

// discoverStruct walks a struct type recursively.
func (td *typeDiscoverer) discoverStruct(thisNode *typeNode, fldPath *field.Path) error {
	var fields []*childNode

	// Discover into each field of this struct.
	for _, memb := range thisNode.valueType.Members {
		name := memb.Name
		if len(name) == 0 { // embedded fields
			if memb.Type.Kind == types.Pointer {
				name = memb.Type.Elem.Name.Name
			} else {
				name = memb.Type.Name.Name
			}
		}
		// Only do exported fields.
		if unicode.IsLower([]rune(name)[0]) {
			continue
		}
		// If we try to emit code for this field and find no JSON name, we
		// will abort.
		jsonName := ""
		if commentTags, ok := tags.LookupJSON(memb); ok {
			jsonName = commentTags.Name
		}

		klog.V(5).InfoS("field", "name", name, "jsonName", jsonName, "type", memb.Type)

		// Discover the field type.
		childPath := fldPath.Child(name)
		childType := memb.Type
		var child *childNode
		if node, err := td.discover(childType, childPath); err != nil {
			return err
		} else {
			child = &childNode{
				name:      name,
				jsonName:  jsonName,
				childType: childType,
				node:      node,
			}
			// Extract +listMapKeys for correlating object and oldObject
			// during update validation.
			node.listMapKeys = extractListMapKeys(memb)
		}

		// Extract any field-attached validation rules.
		if validations, err := td.validator.ExtractValidations(memb.Type, memb.CommentLines); err != nil {
			return fmt.Errorf("field %s: %w", childPath.String(), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found field-attached validations", "n", validations.Len())
				child.fieldValidations.Add(validations)
				if len(validations.Variables) > 0 {
					return fmt.Errorf("variable generation not supported for field-attached validations, but validations on %s require variable generation", childPath.String())
				}
			}
		}

		// Add any other field-attached "special" validators.
		switch childType.Kind {
		case types.Slice, types.Array:
			// Extract any embedded list-validation rules.
			//TODO: also support +k8s:eachVal
			if validations, err := td.extractEmbeddedValidations(eachValTag, memb.CommentLines, childType.Elem); err != nil {
				return fmt.Errorf("%v: %w", childPath.Key("vals"), err)
			} else {
				if !validations.Empty() {
					klog.V(5).InfoS("found list-validations", "n", validations.Len())
					child.elemValidations = validations
					if len(validations.Variables) > 0 {
						return fmt.Errorf("variable generation not supported for field-attached validations, but validations on %s require variable generation", childPath.String())
					}
				}
			}
		case types.Map:
			// Extract any embedded key-validation rules.
			//TODO: also support +k8s:eachKey
			if validations, err := td.extractEmbeddedValidations(eachKeyTag, memb.CommentLines, childType.Key); err != nil {
				return fmt.Errorf("%v: %w", childPath.Key("keys"), err)
			} else {
				if !validations.Empty() {
					klog.V(5).InfoS("found key-validations", "n", validations.Len())
					child.keyValidations = validations
					if len(validations.Variables) > 0 {
						return fmt.Errorf("variable generation not supported for field-attached validations, but validations on %s require variable generation", childPath.String())
					}
				}
			}
			// Extract any embedded val-validation rules.
			//TODO: also support +k8s:eachVal
			if validations, err := td.extractEmbeddedValidations(eachValTag, memb.CommentLines, childType.Elem); err != nil {
				return fmt.Errorf("%v: %w", childPath.Key("vals"), err)
			} else {
				if !validations.Empty() {
					klog.V(5).InfoS("found list-validations", "n", validations.Len())
					child.elemValidations = validations
					if len(validations.Variables) > 0 {
						return fmt.Errorf("variable generation not supported for field-attached validations, but validations on %s require variable generation", childPath.String())
					}
				}
			}
		}

		fields = append(fields, child)
	}

	thisNode.fields = fields
	return nil
}

// discoverAlias walks an alias type recursively.
func (td *typeDiscoverer) discoverAlias(thisNode *typeNode, fldPath *field.Path) error {
	t := thisNode.valueType
	underlying := t.Underlying

	// Note: By the language definition, what gengo calls "Aliases" (really
	// just "type definitions") have underlying types of the type literal.
	// In other words, if we define `type T1 string` and `type T2 T1`, the
	// underlying type of T2 is string, not T1.  This means that:
	//    1) We will emit code for both underlying types. If the underlying
	//       type is a struct with many fields, we will emit two identical
	//       functions.
	//    2) Validating a field of type T2 will NOT call any validation
	//       defined on the type T1.
	//    3) In the case of a type definition whose RHS is a struct which
	//       has fields with validation tags, the validation for those fields
	//       WILL be called from the generated for for the new type.

	// Discover the underlying type.
	var child *childNode
	if node, err := td.discover(underlying, fldPath); err != nil {
		return err
	} else {
		child = &childNode{
			childType: underlying,
			node:      node,
		}
	}
	thisNode.underlying = child

	// Add any other type-attached "special" validators.
	switch underlying.Kind {
	case types.Slice, types.Array:
		// Extract any embedded list-validation rules.
		//TODO: also support +k8s:eachVal
		if validations, err := td.extractEmbeddedValidations(eachValTag, thisNode.valueType.CommentLines, underlying); err != nil {
			return fmt.Errorf("%v: %w", fldPath.Key("vals"), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found list-validations", "n", validations.Len())
				child.elemValidations = validations
			}
		}
	case types.Map:
		// Extract any embedded key-validation rules.
		//TODO: also support +k8s:eachKey
		if validations, err := td.extractEmbeddedValidations(eachKeyTag, thisNode.valueType.CommentLines, underlying); err != nil {
			return fmt.Errorf("%v: %w", fldPath.Key("keys"), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found key-validations", "n", validations.Len())
				child.keyValidations = validations
			}
		}
		// Extract any embedded val-validation rules.
		//TODO: also support +k8s:eachVal
		if validations, err := td.extractEmbeddedValidations(eachValTag, thisNode.valueType.CommentLines, underlying); err != nil {
			return fmt.Errorf("%v: %w", fldPath.Key("vals"), err)
		} else {
			if !validations.Empty() {
				klog.V(5).InfoS("found val-validations", "n", validations.Len())
				child.elemValidations = validations
			}
		}
	}

	return nil
}

func (td *typeDiscoverer) extractEmbeddedValidations(tag string, comments []string, t *types.Type) (validators.Validations, error) {
	var result validators.Validations
	if tagVals, found := gengo.ExtractCommentTags("+", comments)[tag]; found {
		for _, tagVal := range tagVals {
			fakeComments := []string{tagVal}
			if validations, err := td.validator.ExtractValidations(t, fakeComments); err != nil {
				return result, err
			} else {
				result.Add(validations)
			}
		}
	}
	return result, nil
}

// getValidationFunctionName looks up the name of the specified type's
// validation function.
//
// TODO: Currently this is a "blind" call - we hope that the expected function
// exists, but we don't verify that, and we only emit calls into packages which
// are being processed by this generator. For cross-package calls we will need
// to verify the target, either by naming convention + fingerprint or by
// explicit comment-tags or something.
func (td *typeDiscoverer) getValidationFunctionName(t *types.Type) (types.Name, bool) {
	pkg, ok := td.inputToPkg[t.Name.Package]
	if !ok {
		return types.Name{}, false
	}
	return types.Name{Package: pkg, Name: "Validate_" + t.Name.Name}, true
}

func mkSymbolArgs(c *generator.Context, names []types.Name) generator.Args {
	args := generator.Args{}
	for _, name := range names {
		args[name.Name] = c.Universe.Type(name)
	}
	return args
}

// emitRegisterFunction emits the type-registration logic for validation
// functions.
func (g *genValidations) emitRegisterFunction(c *generator.Context, schemeRegistry types.Name, sw *generator.SnippetWriter) {
	scheme := c.Universe.Type(schemeRegistry)
	schemePtr := &types.Type{
		Kind: types.Pointer,
		Elem: scheme,
	}

	sw.Do("func init() { localSchemeBuilder.Register(RegisterValidations)}\n\n", nil)

	sw.Do("// RegisterValidations adds validation functions to the given scheme.\n", nil)
	sw.Do("// Public to allow building arbitrary schemes.\n", nil)
	sw.Do("func RegisterValidations(scheme $.|raw$) error {\n", schemePtr)
	for _, rootType := range g.rootTypes {
		node := g.discovered.typeNodes[rootType]
		if node == nil {
			panic(fmt.Sprintf("found nil node for root-type %v", rootType))
		}

		// TODO: It would be nice if these were not hard-coded.
		var statusType *types.Type
		var statusField string
		if status := node.lookupField("status"); status != nil {
			statusType = status.node.valueType
			statusField = status.name
		}

		targs := generator.Args{
			"rootType":    rootType,
			"typePfx":     "",
			"statusType":  statusType,
			"statusField": statusField,
			"field":       mkSymbolArgs(c, fieldPkgSymbols),
			"fmt":         mkSymbolArgs(c, fmtPkgSymbols),
			"operation":   mkSymbolArgs(c, operationPkgSymbols),
			"safe":        mkSymbolArgs(c, safePkgSymbols),
		}
		if !isNilableType(rootType) {
			targs["typePfx"] = "*"
		}

		// This uses a typed nil pointer, rather than a real instance because
		// we need the type information, but not an instance of the type.
		sw.Do("scheme.AddValidationFunc(", targs)
		sw.Do("    ($.typePfx$$.rootType|raw$)(nil), ", targs)
		sw.Do("    func(opCtx $.operation.Context|raw$, obj, oldObj interface{}, ", targs)
		sw.Do("    subresources ...string) $.field.ErrorList|raw$ {\n", targs)
		sw.Do("  if len(subresources) == 0 {\n", targs)
		sw.Do("    return $.rootType|objectvalidationfn$(", targs)
		sw.Do("               opCtx, ", targs)
		sw.Do("               obj.($.typePfx$$.rootType|raw$), ", targs)
		sw.Do("               $.safe.Cast|raw$[$.typePfx$$.rootType|raw$](oldObj), ", targs)
		sw.Do("               nil)\n", targs)
		sw.Do("  }\n", targs)

		if statusType != nil {
			sw.Do("  if len(subresources) == 1 && subresources[0] == \"status\" {\n", targs)
			if g.hasValidations(g.discovered.typeNodes[statusType]) {
				sw.Do("    root := obj.($.typePfx$$.rootType|raw$)\n", targs)
				sw.Do("    return $.statusType|objectvalidationfn$(", targs)
				sw.Do("               opCtx, ", targs)
				sw.Do("               &root.$.statusField$, ", targs)
				sw.Do("               $.safe.Field|raw$(", targs)
				sw.Do("                   $.safe.Cast|raw$[$.typePfx$$.rootType|raw$](oldObj), ", targs)
				sw.Do("                   func(oldObj $.typePfx$$.rootType|raw$) $.statusType|raw$ { return oldObj.$.statusField$ }), ", targs)
				sw.Do("                   nil)\n", targs)
			} else {
				sw.Do("    return nil // $.statusType|raw$ has no validation\n", targs)
			}
			sw.Do("  }\n", targs)
		}
		sw.Do("  return $.field.ErrorList|raw${", targs)
		sw.Do("      $.field.InternalError|raw$(", targs)
		sw.Do("          nil, ", targs)
		sw.Do("          $.fmt.Errorf|raw$(\"no validation found for %T, subresources: %v\", obj, subresources))", targs)
		sw.Do("  }\n", targs)
		sw.Do("})\n", targs)
	}
	sw.Do("return nil\n", nil)
	sw.Do("}\n\n", nil)
}

// emitValidationFunction emits a validation function for the specified type.
func (g *genValidations) emitValidationFunction(c *generator.Context, t *types.Type, sw *generator.SnippetWriter) {
	targs := generator.Args{
		"inType":     t,
		"field":      mkSymbolArgs(c, fieldPkgSymbols),
		"operation":  mkSymbolArgs(c, operationPkgSymbols),
		"objTypePfx": "*",
	}
	if isNilableType(t) {
		targs["objTypePfx"] = ""
	}

	node := g.discovered.typeNodes[t]
	if node == nil {
		panic(fmt.Sprintf("found nil node for root-type %v", t))
	}
	sw.Do("func $.inType|objectvalidationfn$(", targs)
	sw.Do("    opCtx $.operation.Context|raw$, ", targs)
	sw.Do("    obj, oldObj $.objTypePfx$$.inType|raw$, ", targs)
	sw.Do("    fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
	fakeChild := &childNode{
		node:      node,
		childType: t,
	}
	g.emitValidationForChild(c, fakeChild, sw)
	sw.Do("return errs\n", nil)
	sw.Do("}\n\n", nil)
}

// emitValidationForChild emits code for the specified childNode, calling
// type-attached validations and then descending into the type (e.g. struct
// fields).
//
// Emitted code assumes that the value in question is always a pair of nilable
// variables named "obj" and "oldObj", and the field path to this value is
// named "fldPath".
func (g *genValidations) emitValidationForChild(c *generator.Context, thisChild *childNode, sw *generator.SnippetWriter) {
	thisNode := thisChild.node
	inType := thisNode.valueType

	targs := generator.Args{
		"inType": inType,
		"field":  mkSymbolArgs(c, fieldPkgSymbols),
		"safe":   mkSymbolArgs(c, safePkgSymbols),
	}

	didSome := false // for prettier output later

	// Emit code for type-attached validations.
	if validations := thisNode.typeValidations; !validations.Empty() {
		sw.Do("// type $.inType|raw$\n", targs)
		emitCallsToValidators(c, validations.Functions, sw)
		sw.Do("\n", nil)
		didSome = true
	}

	// Descend into the type.
	switch inType.Kind {
	case types.Builtin:
		// Nothing further.
	case types.Alias:
		g.emitValidationForChild(c, thisNode.underlying, sw)
	case types.Struct:
		for _, fld := range thisNode.fields {
			if len(fld.name) == 0 {
				panic(fmt.Sprintf("missing field name in type %s (field-type %s)", thisNode.valueType, fld.childType))
			}
			// Missing JSON name is checked iff we have code to emit.

			// Accumulate into a buffer so we don't emit empty functions.
			buf := bytes.NewBuffer(nil)
			bufsw := sw.Dup(buf)

			validations := fld.fieldValidations
			if !validations.Empty() {
				emitCallsToValidators(c, validations.Functions, bufsw)
			}

			// Get to the real type.
			switch fld.node.valueType.Kind {
			case types.Alias:
				// Emit for the underlying type.
				g.emitValidationForChild(c, fld.node.underlying, bufsw)
				// Call the type's validation function.
				g.emitCallToOtherTypeFunc(c, fld.node, bufsw)
			case types.Struct:
				// Call the type's validation function.
				g.emitCallToOtherTypeFunc(c, fld.node, bufsw)
			default:
				// Descend into this field.
				g.emitValidationForChild(c, fld, bufsw)
			}

			if buf.Len() > 0 {
				if len(fld.jsonName) == 0 {
					continue // TODO: Embedded (inline) types are expected to be unnamed.
				}

				leafType, typePfx, exprPfx := getLeafTypeAndPrefixes(fld.childType)
				targs := targs.WithArgs(generator.Args{
					"fieldName":    fld.name,
					"fieldJSON":    fld.jsonName,
					"fieldType":    leafType,
					"fieldTypePfx": typePfx,
					"fieldExprPfx": exprPfx,
				})

				if didSome {
					sw.Do("\n", nil)
				}
				sw.Do("// field $.inType|raw$.$.fieldName$\n", targs)
				sw.Do("errs = append(errs,\n", targs)
				sw.Do("  func(obj, oldObj $.fieldTypePfx$$.fieldType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
				sw.Append(buf)
				sw.Do("    return\n", targs)
				sw.Do("  }($.fieldExprPfx$obj.$.fieldName$, ", targs)
				sw.Do("    $.safe.Field|raw$(oldObj, ", targs)
				sw.Do("        func(oldObj *$.inType|raw$) $.fieldTypePfx$$.fieldType|raw$ {", targs)
				sw.Do("            return $.fieldExprPfx$oldObj.$.fieldName$", targs)
				sw.Do("        }),", targs)
				sw.Do("    fldPath.Child(\"$.fieldJSON$\"))...)\n", targs)
				sw.Do("\n", nil)
			} else {
				targs := targs.WithArgs(generator.Args{
					"fieldName": fld.name,
				})
				sw.Do("// field $.inType|raw$.$.fieldName$ has no validation\n", targs)
			}
			didSome = true
		}
	case types.Slice, types.Array:
		// Accumulate into a buffer so we don't emit empty functions.
		elemBuf := bytes.NewBuffer(nil)
		elemSW := sw.Dup(elemBuf)

		// Validate each value.
		validations := thisNode.elemValidations
		validations.Add(thisChild.elemValidations)
		if !validations.Empty() {
			emitCallsToValidators(c, validations.Functions, elemSW)
		}

		switch thisNode.elem.node.valueType.Kind {
		case types.Struct, types.Alias:
			// If this field is another type, call its validation function.
			// Checking for nil is handled inside this call.
			g.emitCallToOtherTypeFunc(c, thisNode.elem.node, elemSW)
		default:
			// No need to go further.  Struct- or alias-typed fields might have
			// validations attached to the type, but anything else (e.g.
			// string) can't, and we already emitted code for the field
			// validations.
		}

		if elemBuf.Len() > 0 {
			leafType, typePfx, exprPfx := getLeafTypeAndPrefixes(inType.Elem)
			targs := targs.WithArgs(generator.Args{
				"elemType":    leafType,
				"elemTypePfx": typePfx,
				"elemExprPfx": exprPfx,
			})

			isCorrelatable := len(thisNode.listMapKeys) > 0
			oldVal := "nil" // updated below if needed

			// Lookup corresponding old slice elem values for update validation using a traverse.ListMap.
			// Only +listType=map slices have corresponding old values. Corresponding old values have matching
			// +listMapKey values.
			if isCorrelatable {
				// Note: this func returns 'any' but it's always an array (not
				// slice) of 'any', and those should always be comparable, so
				// we should not see runtime errors ("comparing uncomparable
				// type").
				sw.Do("oldListMap := $.safe.NewListMap|raw$(oldObj, func(o $.elemTypePfx$$.elemType|raw$) any {", targs)
				sw.Do(" return ", targs)
				emitListMapKey(sw, "o", thisNode)
				sw.Do("})\n", targs)
				oldVal = "oldListMap.WithMatchingKey(val)"
			}
			targs["oldVal"] = oldVal

			sw.Do("for i, val := range obj {\n", targs)
			sw.Do("  errs = append(errs,\n", targs)
			sw.Do("    func(obj, oldObj $.elemTypePfx$$.elemType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
			sw.Append(elemBuf)
			sw.Do("      return\n", targs)
			sw.Do("    }($.elemExprPfx$val, $.oldVal$, fldPath.Index(i))...)\n", targs)
			sw.Do("}\n", nil)
		}
	case types.Map:
		// Accumulate into a buffer so we don't emit empty functions.
		keyBuf := bytes.NewBuffer(nil)
		keySW := sw.Dup(keyBuf)

		// Validate each key.
		keyValidations := thisNode.keyValidations
		keyValidations.Add(thisChild.keyValidations)
		if !keyValidations.Empty() {
			emitCallsToValidators(c, keyValidations.Functions, keySW)
		}

		switch thisNode.key.node.valueType.Kind {
		case types.Struct, types.Alias:
			// If this field is another type, call its validation function.
			// Checking for nil is handled inside this call.
			g.emitCallToOtherTypeFunc(c, thisNode.key.node, keySW)
		default:
			// No need to go further.  Struct- or alias-typed fields might have
			// validations attached to the type, but anything else (e.g.
			// string) can't, and we already emitted code for the field
			// validations.
		}

		// Accumulate into a buffer so we don't emit empty functions.
		valBuf := bytes.NewBuffer(nil)
		valSW := sw.Dup(valBuf)

		// Validate each value.
		valValidations := thisNode.elemValidations
		valValidations.Add(thisChild.elemValidations)
		if !valValidations.Empty() {
			emitCallsToValidators(c, valValidations.Functions, valSW)
		}

		switch thisNode.elem.node.valueType.Kind {
		case types.Struct, types.Alias:
			// If this field is another type, call its validation function.
			// Checking for nil is handled inside this call.
			g.emitCallToOtherTypeFunc(c, thisNode.elem.node, valSW)
		default:
			// No need to go further.  Struct- or alias-typed fields might have
			// validations attached to the type, but anything else (e.g.
			// string) can't, and we already emitted code for the field
			// validations.
		}

		vName := "_"
		if valBuf.Len() > 0 {
			vName = "val"
		}
		if keyBuf.Len()+valBuf.Len() > 0 {
			valLeafType, valTypePfx, valExprPfx := getLeafTypeAndPrefixes(inType.Elem)
			targs := targs.WithArgs(generator.Args{
				"keyType":    inType.Key, // we only handle ~string keys
				"valType":    valLeafType,
				"valTypePfx": valTypePfx,
				"valExprPfx": valExprPfx,
			})
			if !isNilableType(inType.Elem) {
				// E.g. map[string]StructType => *StructType
				targs["xform"] = targs["safe"].(generator.Args)["PtrTo"]
			} else if inType.Elem.Kind == types.Pointer && isNilableType(inType.Elem.Elem) {
				// E.g. given type E []StructType, map[string]*E => E
				targs["xform"] = targs["safe"].(generator.Args)["Deref"]
			} else {
				// E.g. map[string]*StructType => StructType
				targs["xform"] = targs["safe"].(generator.Args)["Ident"]
			}

			sw.Do("for key, $.val$ := range obj {\n", targs.With("val", vName))
			if keyBuf.Len() > 0 {
				sw.Do("  errs = append(errs,\n", targs)
				sw.Do("    func(obj, oldObj *$.keyType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
				sw.Append(keyBuf)
				sw.Do("      return\n", targs)
				sw.Do("    }(&key, nil, fldPath)...)\n", targs) // We don't match up map keys with a corresponding old value
			}
			if valBuf.Len() > 0 {
				sw.Do("  errs = append(errs,\n", targs)
				sw.Do("    func(obj, oldObj $.valTypePfx$$.valType|raw$, fldPath *$.field.Path|raw$) (errs $.field.ErrorList|raw$) {\n", targs)
				sw.Append(valBuf)
				sw.Do("      return\n", targs)
				sw.Do("    }($.valExprPfx$val, $.safe.Lookup|raw$(oldObj, key, $.xform|raw$), fldPath.Key(string(key)))...)\n", targs)
			}

			sw.Do("}\n", nil)
		}
	default:
		panic(fmt.Sprintf("unhandled type: %v (kind %s)", inType, inType.Kind))
	}
}

// emitListMapKey emits an arrays of key fields values representing the key of a listType=map typeNode.
// The emitted array can be used as a go map key. An array is used instead of a slice because slices
// may not be used as map keys in go.
func emitListMapKey(sw *generator.SnippetWriter, varName string, node *typeNode) {
	targs := generator.Args{
		"varName":     varName,
		"memberCount": len(node.listMapKeys),
	}
	sw.Do("[$.memberCount$]any{", targs)
	for i, member := range node.listMapKeys {
		targs["member"] = member.Name
		sw.Do("$.varName$.$.member$", targs)
		if i < len(node.listMapKeys)-1 {
			sw.Do(",  ", nil)
		}
	}
	sw.Do("}", targs)
}

// emitCallToOtherTypeFunc generates a call to the specified node's generated
// validation function for a field in some parent context.
//
// Emitted code assumes that the value in question is always a pair of nilable
// variables named "obj" and "oldObj", and the field path to this value is
// named "fldPath".
func (g *genValidations) emitCallToOtherTypeFunc(c *generator.Context, node *typeNode, sw *generator.SnippetWriter) {
	// If this type has no validations (transitively) then we don't need to do
	// anything.
	if !g.hasValidations(node) {
		return
	}

	targs := generator.Args{
		"funcName": c.Universe.Type(node.funcName),
	}
	sw.Do("errs = append(errs, $.funcName|raw$(opCtx, obj, oldObj, fldPath)...)\n", targs)
}

// emitCallsToValidators emits calls to a list of validation functions for
// a single field or type. validations is a list of functions to call, with
// arguments.
//
// When calling registered validators, we always pass a nilable type.  E.g. if
// the field's type is string, we pass *string, and if the field's type is
// *string, we also pass *string.  This means that validators need to do
// nil-checks themselves, if they intend to dereference the pointer.  This
// makes updates more consistent.
//
// Emitted code assumes that the value in question is always a pair of nilable
// variables named "obj" and "oldObj", and the field path to this value is
// named "fldPath".
func emitCallsToValidators(c *generator.Context, validations []validators.FunctionGen, sw *generator.SnippetWriter) {
	// Helper func
	sort := func(in []validators.FunctionGen) []validators.FunctionGen {
		fatal := make([]validators.FunctionGen, 0, len(in))
		nonfatal := make([]validators.FunctionGen, 0, len(in))

		for _, fg := range in {
			isFatal := (fg.Flags().IsSet(validators.IsFatal))

			if isFatal {
				fatal = append(fatal, fg)
			} else {
				nonfatal = append(nonfatal, fg)
			}
		}
		result := fatal
		result = append(result, nonfatal...)
		return result
	}

	validations = sort(validations)

	for _, v := range validations {
		isFatal := v.Flags().IsSet(validators.IsFatal)
		isNonError := v.Flags().IsSet(validators.NonError)

		fn, extraArgs := v.SignatureAndArgs()
		targs := generator.Args{
			"funcName": c.Universe.Type(fn),
		}

		emitCall := func() {
			sw.Do("$.funcName|raw$", targs)
			typeArgs := v.TypeArgs()
			if len(typeArgs) > 0 {
				sw.Do("[", nil)
				for i, typeArg := range typeArgs {
					sw.Do("$.|raw$", c.Universe.Type(typeArg))
					if i < len(typeArgs)-1 {
						sw.Do(",", nil)
					}
				}
				sw.Do("]", nil)
			}
			sw.Do("(opCtx, fldPath, obj, oldObj", targs)
			for _, arg := range extraArgs {
				sw.Do(", ", nil)
				toGolangSourceDataLiteral(sw, c, arg)
			}
			sw.Do(")", targs)
		}

		if isFatal {
			sw.Do("if e := ", nil)
			emitCall()
			sw.Do("; len(e) != 0 {\n", nil)
			if !isNonError {
				sw.Do("errs = append(errs, e...)\n", nil)
			}
			sw.Do("    return // do not proceed\n", nil)
			sw.Do("}\n", nil)
		} else {
			if isNonError {
				emitCall()
			} else {
				sw.Do("errs = append(errs, ", nil)
				emitCall()
				sw.Do("...)\n", nil)
			}
		}
	}
}

// emitValidationVariables emits a list of variable declarations. Each variable declaration has a
// private (unexported) variable name, and a function invocation declaration that is expected
// to initialize the value of the variable.
func (g *genValidations) emitValidationVariables(c *generator.Context, t *types.Type, sw *generator.SnippetWriter) {
	tn := g.discovered.typeNodes[t]

	variables := tn.typeValidations.Variables
	slices.SortFunc(variables, func(a, b validators.VariableGen) int {
		return cmp.Compare(a.Var().Name, b.Var().Name)
	})
	for _, variable := range variables {
		supportInitFn, supportInitArgs := variable.Init().SignatureAndArgs()
		targs := generator.Args{
			"varName": c.Universe.Type(types.Name(variable.Var())),
			"initFn":  c.Universe.Type(supportInitFn),
		}
		sw.Do("var $.varName|private$ = $.initFn|raw$", targs)
		typeArgs := variable.Init().TypeArgs()
		if len(typeArgs) > 0 {
			sw.Do("[", nil)
			for i, typeArg := range typeArgs {
				sw.Do("$.|raw$", c.Universe.Type(typeArg))
				if i < len(typeArgs)-1 {
					sw.Do(",", nil)
				}
			}
			sw.Do("]", nil)
		}
		sw.Do("(", targs)
		for i, arg := range supportInitArgs {
			toGolangSourceDataLiteral(sw, c, arg)
			if i < len(supportInitArgs)-1 {
				sw.Do(", ", nil)
			}
		}
		sw.Do(")\n", nil)

	}
}

func toGolangSourceDataLiteral(sw *generator.SnippetWriter, c *generator.Context, value any) {
	// For safety, be strict in what values we output to visited source, and ensure strings
	// are quoted.

	switch v := value.(type) {
	case uint, uint8, uint16, uint32, uint64, int, int8, int16, int32, int64, float32, float64, bool:
		sw.Do(fmt.Sprintf("%v", value), nil)
	case string:
		// If the incoming string was quoted, we still do it ourselves, JIC.
		str := value.(string)
		if s, err := strconv.Unquote(str); err == nil {
			str = s
		}
		sw.Do(fmt.Sprintf("%q", str), nil)
	case *types.Type:
		sw.Do("$.|raw$", v)
	case types.Member:
		sw.Do("obj."+v.Name, nil)
	case validators.Identifier:
		sw.Do("$.|raw$", c.Universe.Type(types.Name(v)))
	case *validators.Identifier:
		sw.Do("$.|raw$", c.Universe.Type(types.Name(*v)))
	case validators.PrivateVar:
		sw.Do("$.|private$", c.Universe.Type(types.Name(v)))
	case *validators.PrivateVar:
		sw.Do("$.|private$", c.Universe.Type(types.Name(*v)))
	default:
		rv := reflect.ValueOf(value)
		switch rv.Kind() {
		case reflect.Slice, reflect.Array:
			arraySize := ""
			if rv.Kind() == reflect.Array {
				arraySize = strconv.Itoa(rv.Len())
			}
			var itemType string
			switch rv.Type().Elem().Kind() {
			case reflect.String: // For now, only support lists of strings.
				itemType = rv.Type().Elem().Name()
			default:
				panic(fmt.Sprintf("Unsupported extraArg type: %T", value))
			}
			rv.Type().Elem()
			sw.Do("[$.arraySize$]$.itemType${", map[string]string{"arraySize": arraySize, "itemType": itemType})
			for i := 0; i < rv.Len(); i++ {
				val := rv.Index(i)
				toGolangSourceDataLiteral(sw, c, val.Interface())
				if i < rv.Len()-1 {
					sw.Do(", ", nil)
				}
			}
			sw.Do("}", nil)
		default:
			// TODO: check this during discovery and emit an error with more useful information
			panic(fmt.Sprintf("Unsupported extraArg type: %T", value))
		}
	}
}

func extractListMapKeys(member types.Member) []types.Member {
	var result []types.Member
	if values, ok := gengo.ExtractCommentTags("+", member.CommentLines)["listMapKey"]; ok {
		for _, val := range values {
			for _, m := range member.Type.Elem.Members {
				tags, ok := tags.LookupJSON(m)
				if !ok {
					panic(fmt.Sprintf("listMapKey refers to field that does not have a JSON go struct tag: %v", m.Name))
				}
				if tags.Name == val {
					result = append(result, m)
				}
			}
		}
	}
	return result
}

func isNilableType(t *types.Type) bool {
	for t.Kind == types.Alias {
		t = t.Underlying
	}
	switch t.Kind {
	case types.Pointer, types.Map, types.Slice, types.Interface: // Note: Arrays are not nilable
		return true
	}
	return false
}

// getLeafTypeAndPrefixes returns the "leaf value type" for a given type, as
// well as type and expression prefix strings for the input type.  The type
// prefix can be prepended to the given type's name to produce the nilable form
// of that type.  The expression prefix can be prepended to a variable of the
// given type to produce the nilable form of that value.
//
// Example: Given an input type "string" this should produce (string, "*", "&").
// That is to say: the value-type is "string", which yields "*string" when the
// type prefix is applied, and a variable "x" becomes "&x" when the expression
// prefix is applied.
//
// Example: Given an input type "*string" this should produce (string, "*", "").
// That is to say: the value-type is "string", which yields "*string" when the
// type prefix is applied, and a variable "x" remains "x" when the expression
// prefix is applied.
func getLeafTypeAndPrefixes(inType *types.Type) (*types.Type, string, string) {
	leafType := inType
	typePfx := ""
	exprPfx := ""

	nPtrs := 0
	for leafType.Kind == types.Pointer {
		nPtrs++
		leafType = leafType.Elem
	}
	if !isNilableType(leafType) {
		typePfx = "*"
		if nPtrs == 0 {
			exprPfx = "&"
		} else {
			exprPfx = strings.Repeat("*", nPtrs-1)
		}
	} else {
		exprPfx = strings.Repeat("*", nPtrs)
	}

	return leafType, typePfx, exprPfx
}
